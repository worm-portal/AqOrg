<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>AqOrg.AqOrg API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>AqOrg.AqOrg</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from IPython.display import SVG
from rdkit import Chem
from rdkit.Chem import rdDepictor, Draw
from rdkit.Chem.Draw import rdMolDraw2D
import pandas as pd
import math
import sigfig
import pubchempy as pcp
import os
from chemparse import parse_formula
import pkg_resources
from datetime import datetime
from WORMutils import Error_Handler, find_HKF

def find_sigfigs(x):
    
    &#39;&#39;&#39;
    Get the number of significant digits in a string representing a number up to
    eight digits long.

    Parameters
    ----------
    x : str
        A string denoting a number. This can include scientific notation.
    
    Parameters
    ----------
    int
        The number of significant digits.
    
    Examples
    --------
    &gt;&gt;&gt; find_sigfigs(&#34;5.220&#34;)
    4
    
    This also takes into account scientific notation.
    
    &gt;&gt;&gt; find_sigfigs(&#34;1.23e+3&#34;)
    3
    
    Insignificant zeros are ignored.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000&#34;)
    1
    
    A decimal point denotes that zeros are significant.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000.&#34;)
    4
    &#39;&#39;&#39;
    
    x = str(x)
    
    # change all the &#39;E&#39; to &#39;e&#39;
    x = x.lower()
    if (&#39;-&#39; == x[0]):
        x = x[1:]
    if (&#39;e&#39; in x):
        # return the length of the numbers before the &#39;e&#39;
        myStr = x.split(&#39;e&#39;)
        return len(myStr[0]) - 1  # to compenstate for the decimal point
    else:
        # put it in e format and return the result of that
        ### NOTE: because of the 8 below, it may do crazy things when it parses 9 sigfigs
        n = (&#39;%.*e&#39; % (8, float(x))).split(&#39;e&#39;)
        # remove and count the number of removed user added zeroes. (these are sig figs)
        if &#39;.&#39; in x:
            s = x.replace(&#39;.&#39;, &#39;&#39;)
            #number of zeroes to add back in
            l = len(s) - len(s.rstrip(&#39;0&#39;))
            #strip off the python added zeroes and add back in the ones the user added
            n[0] = n[0].rstrip(&#39;0&#39;) + &#39;&#39;.join([&#39;0&#39; for num in range(l)])
        else:
            #the user had no trailing zeroes so just strip them all
            n[0] = n[0].rstrip(&#39;0&#39;)
        #pass it back to the beginning to be parsed
    return find_sigfigs(&#39;e&#39;.join(n))


class Estimate():
    
    &#34;&#34;&#34;
    Estimate thermodynamic properties of an aqueous organic molecule.
    
    Parameters
    ----------
    name : str
        Name of the aqueous organic molecule that will have its thermodynamic
        properties estimated.
                       
    show : bool, default True
        Show a diagram of the molecule?
    
    group_data : str, optional
        Name of a CSV containing custom group contribution data.
    
    test : bool, default False
        Perform a simple group matching test instead of estimating properties?

    state : str, default &#34;aq&#34;
        Can be &#34;aq&#34; or &#34;gas&#34;. Estimate the properties of an aqueous molecule or
        an ideal gas?

    save : bool, default False
        Save molecular structure figures as PNG and SVG?
    
    **kwargs : numeric or str, optional
        Known standard state partial molal thermodynamic properties at 298.15 K
        and 1 bar. These will not be estimated, but instead will be used to
        estimate other properties and parameters. Valid **kwargs include:
        
        - Gh : Gibbs free energy change of hydration, kJ/mol.
        - Hh : Enthalpy change of hydration, kJ/mol.
        - Sh : Entropy change of hydration, J/mol/K.
        - Cph : Heat capacity change of hydration, J/mol/K.
        - V : Volume change of hydration, cm3/mol.
        - Gh_err : Error associated with Gh (default 0 kJ/mol).
        - Hh_err : Error associated with Hh (default 0 kJ/mol).
        - Sh_err : Error associated with Sh (default 0 J/mol/K).
        - Cph_err : Error associated with Cph (default 0 J/mol/K).
        - V_err : error associated with V (default 0 cm3/mol).
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
        - Gaq : Aqueous Gibbs free energy of formation, kJ/mol.
        - Haq : Aqueous enthalpy of formation, kJ/mol.
        - Saq : Aqueous entropy, J/mol/K.
        - Cpaq : Aqueous isobaric heat capacity, J/mol/K.
    
    Attributes
    ----------
    pcp_compound : pcp.get_compounds()
        PubChemPy compound object.
        
    smiles : str
        Canonical SMILES string.
        
    formula : str
        Molecular formula.
        
    formula_dict : dict
        Dictionary of element abundance in the molecular formula.
        
    element_data : pd.DataFrame()
        Table of element data adapted from Jeff Dick&#39;s CHNOSZ package for R.
        
    Selements : numeric
        Sum of the contributions of the entropies of the elements according to
        Cox, J. D., Wagman, D. D., &amp; Medvedev, V. A. (1989). CODATA key values
        for thermodynamics. Chem/Mats-Sci/E.
        
    note : str
        Notes and warnings associated with the estimation.
        
    charge : numeric
        The charge of the molecule.
        
    OBIGT : pd.DataFrame()
        Table of estimated thermodynamic properties and parameters. The format
        is styled after Jeff Dick&#39;s OBIGT thermodynamic table in the CHNOSZ
        package (see https://chnosz.net/manual/thermo.html).

    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this function?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    
    def __init__(self, name, show=True, group_data=None,
                       test=False, state=&#39;aq&#39;, save=False, hide_traceback=True,
                       **kwargs):
                       # E_units=&#34;J&#34; # not implemented... tricky because groups
                                     # are in both kJ and J units.

        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.name = name
        
        # valid kwargs
        self.Gh = None
        self.Hh = None
        self.Sh = None
        self.Cph = None
        self.V = None
        self.Gh_err = 0
        self.Hh_err = 0
        self.Sh_err = 0
        self.Cph_err = 0
        self.V_err = 0
        self.Gig = None
        self.Hig = None
        self.Sig = None
        self.Cpig_a = None
        self.Cpig_b = None
        self.Cpig_c = None
        self.Cpig_d = None
        self.Cpig = None
        self.Gaq = None
        self.Haq = None
        self.Saq = None
        self.Cpaq = None

        for key, value in kwargs.items():
            self.__setattr__(key, value)
        
        # load group contribution data
        if group_data == None:
            if state == &#34;aq&#34;:
                group_data = pkg_resources.resource_stream(__name__, &#34;data/group_contribution_data.csv&#34;)
            elif state == &#34;gas&#34;:
                group_data=pkg_resources.resource_stream(__name__, &#39;data/joback_groups.csv&#39;)
            else:
                self.err_handler.raise_exception(&#34;State is unrecognized. Must be either &#39;aq&#39; or &#39;gas&#39;.&#34;)
        self.__load_group_data(group_data)
        
        # look up compound on PubChem
        self.pcp_compound = pcp.get_compounds(self.name, &#34;name&#34;)
        if len(self.pcp_compound) == 0:
            self.err_handler.raise_exception(&#34;Could not find &#39;&#34; + self.name + &#34;&#39; in PubChem&#39;s online database.&#34;)
        self.smiles = self.pcp_compound[0].canonical_smiles
        self.formula = self.pcp_compound[0].molecular_formula
        self.formula_dict = parse_formula(self.formula)
        
        if &#34;-&#34; in self.formula_dict.keys() or &#34;+&#34; in self.formula_dict.keys():
            self.err_handler.raise_exception(self.name + &#34; cannot be estimated because it has a net charge.&#34;)

        if show:
            self.__display_molecule(save=save)

        if test:
            print(self.__test_group_match())            
        else:
            # load properties of the elements
            # Cox, J. D., Wagman, D. D., and Medvedev, V. A., CODATA Key Values
            # for Thermodynamics, Hemisphere Publishing Corp., New York, 1989.
            # Compiled into a CSV by Jeffrey Dick for CHNOSZ
            element_data = pd.read_csv(pkg_resources.resource_stream(__name__, &#39;data/element.csv&#39;), index_col=&#34;element&#34;)
            self.element_data = element_data.loc[element_data[&#39;source&#39;] == &#34;CWM89&#34;]
            
            self.Selements = self.__entropy()
            self.note = &#34;&#34;
            self.charge = 0 # !
            
            if state == &#39;aq&#39;:
                self.OBIGT = self.__estimate()
            elif state == &#39;gas&#39;:
                self.__estimate_joback()

    def __load_group_data(self, db_filename):
        self.group_data = pd.read_csv(db_filename, dtype=str)
        self.group_data[&#39;elem&#39;] = self.group_data[&#39;elem&#39;].fillna(&#39;&#39;)
        self.pattern_dict = pd.Series(self.group_data[&#34;elem&#34;].values,
                                      index=self.group_data[&#34;smarts&#34;]).to_dict()
        self.group_data = self.group_data.set_index(&#34;smarts&#34;)

        
    def __set_groups(self):
        
        self.group_matches = pd.DataFrame(self.__match_groups(), index=[self.name])

        # remove columns with no matches
        self.group_matches = self.group_matches.loc[:, (self.group_matches.sum(axis=0) != 0)]
        
        # get a list of relevent groups
        self.groups = [grp for grp in self.group_matches.columns if grp != &#34;formula&#34;]
        

    def __entropy(self, unit=&#34;J/mol/K&#34;):
        
        &#34;&#34;&#34;
        Calculate the standard molal entropy of elements in a molecule.
        &#34;&#34;&#34;

        entropies = [(self.element_data.loc[elem, &#34;s&#34;]/self.element_data.loc[elem, &#34;n&#34;])*self.formula_dict[elem] for elem in list(self.formula_dict.keys())]
        if unit == &#34;J/mol/K&#34;:
            unit_conv = 4.184
        elif unit == &#34;cal/mol/K&#34;:
            unit_conv = 1
        else:
            print(&#34;Warning in entropy: specified unit&#34;, unit,
                  &#34;is not recognized. Returning entropy in J/mol/K&#34;)
            unit_conv = 4.184
            
        return sum(entropies)*unit_conv

    
    def __dict_to_formula(self, formula_dict):
        
        &#34;&#34;&#34;
        Convert a formula dictionary into a formula string.
        Example:
        ```dict_to_formula(parse_formula(&#34;CO3-2&#34;))```
        &#34;&#34;&#34;
        
        formula_string = &#34;&#34;
        for key in formula_dict.keys():
            if abs(formula_dict[key]) == 1:
                v = &#34;&#34;
            else:
                v = formula_dict[key]
                if (v).is_integer():
                    v = int(v)

            formula_string = formula_string + str(key) + str(v)
        return formula_string

    
    def __match_groups(self, show=False, save=False):
        patterns = self.pattern_dict.keys()
        mol = Chem.MolFromSmiles(self.smiles)

        match_dict = dict(zip(patterns, [0]*len(patterns))) # initialize match_dict
        for pattern in patterns:
            if pattern != &#34;Yo&#34;: # never match material point
                try:
                    match_dict[pattern] = len(mol.GetSubstructMatches(Chem.MolFromSmarts(pattern)))
                except:
                    print(&#34;Warning in match_groups(): problem&#34;,
                          &#34;identifying SMARTS group&#34;, pattern,
                          &#34;. Skipping this group.&#34;)

        ### check that total formula of groups matches that of the molecule
        
        # create a dictionary of element matches
        total_formula_dict = {}
        for match in match_dict.keys():
            this_match = parse_formula(self.pattern_dict[match])
            for element in this_match.keys():
                this_match[element] *= match_dict[match]
                if element in total_formula_dict:
                    total_formula_dict[element] += this_match[element]
                else:
                    total_formula_dict[str(element)] = 0
                    total_formula_dict[element] += this_match[element]
        
        # remove keys of elements with a value of 0 (e.g. &#34;H&#34;:0.0)
        for key in list(total_formula_dict.keys()):
            if total_formula_dict[key] == 0.0:
                total_formula_dict.pop(key, None)
        
        # retrieve individual charges that contribute to net charge
        atomic_info = self.pcp_compound[0].record[&#34;atoms&#34;]
        chargedict = {}
        if &#34;charge&#34; in atomic_info.keys():
            all_charges = [chargedict.get(&#34;value&#34;, 0) for chargedict in atomic_info[&#34;charge&#34;]]
            pos_charge = sum([charge for charge in all_charges if charge &gt; 0])
            neg_charge = abs(sum([charge for charge in all_charges if charge &lt; 0]))
            if pos_charge &gt; 0:
                chargedict[&#39;+&#39;]=float(pos_charge)
            if neg_charge &gt; 0:
                chargedict[&#39;-&#39;]=float(neg_charge)
        else:
            chargedict = {}

        # perform the comparison
        test_dict = parse_formula(self.pcp_compound[0].molecular_formula)
        test_dict.update(chargedict)
        if total_formula_dict != test_dict:
            mssg = &#34;The formula of &#34; + self.name + \
                &#34; does not equal the the elemental composition of the &#34; + \
                &#34;matched groups. This could be because the database &#34; + \
                &#34;is missing representative groups.\nFormula of &#34; + \
                self.name + &#34;:\n&#34;
            pcp_dict = parse_formula(self.pcp_compound[0].molecular_formula)
            pcp_dict.update(chargedict)
            mssg = mssg + str(pcp_dict) + &#34;\nTotal formula of group matches:\n&#34; + \
                str(total_formula_dict)
            mssg = mssg + &#34;\nIncomplete group matches:\n&#34; + \
                str({k:v for k,v in zip(match_dict.keys(), match_dict.values()) if v!= 0})
            self.err_handler.raise_exception(mssg)
        
        # add molecular formula to match dictionary
        match_dict[&#34;formula&#34;] = self.__dict_to_formula(total_formula_dict)
        
        return match_dict

    
    def __display_molecule(self, show=True, save=False):
        mol_smiles = Chem.MolFromSmiles(self.smiles)
        
        mc = Chem.Mol(mol_smiles.ToBinary())
        molSize=(450, 150)
        
        if not mc.GetNumConformers():
            #Compute 2D coordinates
            rdDepictor.Compute2DCoords(mc)
        # init the drawer with the size
        drawer = rdMolDraw2D.MolDraw2DSVG(molSize[0],molSize[1])
        #draw the molcule
        drawer.DrawMolecule(mc)
        drawer.FinishDrawing()
        # get the SVG string
        svg = drawer.GetDrawingText()

        if show:
            # fix the svg string and display it
            display(SVG(svg.replace(&#39;svg:&#39;,&#39;&#39;)))

        if save:
            os.makedirs(&#34;mol_svg&#34;, exist_ok=True)
            os.makedirs(&#34;mol_png&#34;, exist_ok=True)
            #Draw.MolToFile( mol, &#34;mol_svg/&#34;+self.name+&#34;.svg&#34; )
            Draw.MolToFile(mol_smiles, &#34;mol_png/&#34;+self.name+&#34;.png&#34;)


    def __test_group_match(self):
        match_dict = self.__match_groups()
        return {key:value for key,value in zip(match_dict.keys(), match_dict.values()) if value !=0}

    
    def __est_joback(self):
        
        # values to be added to final estimate of each property
        joback_props = {&#34;Gig&#34;:53.88, &#34;Hig&#34;:68.29, # kJ/mol
                        &#34;Cpig_a&#34;:-37.93, &#34;Cpig_b&#34;:0.210, # j/mol/K
                        &#34;Cpig_c&#34;:-3.91*10**-4, &#34;Cpig_d&#34;:2.06*10**-7} # j/mol/K
        
        for prop in joback_props.keys():
            mol_prop = 0
            error_groups = []

            for group in self.groups:

                try:
                    contains_group = self.group_matches.loc[self.name, group][0] != 0
                except:
                    contains_group = self.group_matches.loc[self.name, group] != 0

                # if this molecule contains this group...
                if contains_group:
                    try:
                        # add number of groups multiplied by its contribution
                        mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])
                    except:
                        error_groups.append(group)
                        
                if len(error_groups) == 0:
                    self.__setattr__(prop, mol_prop+joback_props[prop])
                else:
                    self.err_handler.raise_exception(&#34;&#34; + self.name + &#34; encountered errors with group(s): &#34;
                        &#34;&#34;+str(error_groups) + &#34;. Are these groups assigned &#34;
                        &#34;ideal gas properties in the Joback data file?&#34;)
            
        # calculate Cpig
        T=298.15
        self.Cpig = self.Cpig_a + self.Cpig_b*T + self.Cpig_c*T**2 +\
                    self.Cpig_d*T**3
        
        # calculate Sig
        self.Sig = ((self.Gig - self.Hig)/-298.15)*1000 + self.Selements
    
    
    def __est_calcs(self):

        props = [&#34;Gh&#34;, &#34;Hh&#34;, &#34;Sh&#34;, &#34;Cph&#34;, &#34;V&#34;]
        
        for prop in props:
            if self.__getattribute__(prop) == None:
                err_str = prop + &#34;_err&#34;

                # derive Sh, entropy of hydration, in J/mol K
                if prop == &#34;Sh&#34;:
                    # Entropy calculated from S = (G-H)/(-Tref)
                    mol_prop = (float(self.Gh) - float(self.Hh))/(-298.15)
                    mol_prop = mol_prop*1000 # convert kJ/molK to J/molK

                    # propagate error from Gh and Hh to estimate Sh error.
                    # equation used: Sh_err = Sh*sqrt((Gh_err/Gh)**2 + (Hh_err/Hh)**2)
                    Gh_err_float = float(self.Gh_err)/float(self.Gh)
                    Hh_err_float = float(self.Hh_err)/float(self.Hh)
                    mol_err = abs(mol_prop)*math.sqrt(Gh_err_float**2 + Hh_err_float**2)

                    # check whether Gh or Hh as the fewest sigfigs
                    sf = min([find_sigfigs(self.Gh), find_sigfigs(self.Hh)])

                    # round Sh to this number of sigfigs
                    mol_prop = sigfig.round(str(mol_prop), sigfigs=sf)

                    # check how many decimal places Sh has after sigfig rounding
                    if &#34;.&#34; in mol_prop:
                        this_split = mol_prop.split(&#34;.&#34;)
                        n_dec = len(this_split[len(this_split)-1])
                    else:
                        n_dec = 0

                    # assign Sh and Sh_err
                    #self.__setattr__(prop, mol_prop) # for trailing zeros, but must store Sh as str.
                    #self.__setattr__(err_str, format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)) # for trailing zeros, but must store Sh_err as str.
                    self.__setattr__(prop, float(mol_prop))
                    self.__setattr__(err_str, round(float(mol_err), n_dec))


                    continue

                # For all properties except for Sh:
                # initialize variables and lists
                mol_prop = 0
                mol_err = 999
                prop_errs = []
                n_dec = 999
                error_groups = []

                for group in self.groups:

                    try:
                        contains_group = self.group_matches.loc[self.name, group][0] != 0
                    except:
                        contains_group = self.group_matches.loc[self.name, group] != 0

                    # if this molecule contains this group...
                    if contains_group:

                        try:
                            # add number of groups multiplied by its contribution
                            mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])

                            # round property to smallest number of decimal places
                            if &#34;.&#34; in self.group_data.loc[group, prop]:
                                this_split = self.group_data.loc[group, prop].split(&#34;.&#34;)
                                n_dec_group = len(this_split[len(this_split)-1])
                            else:
                                n_dec_group = 0

                            if n_dec_group &lt; n_dec:
                                n_dec = n_dec_group

                            # handle group std errors
                            try:
                                float(self.group_data.loc[group, err_str]) # assert that this group&#39;s error is numeric
                                prop_errs.append(self.group_data.loc[group, err_str]) # append error
                            except:
                                # if group&#39;s error is non-numeric, pass
                                pass

                        except:
                            error_groups.append(group)

                if len(error_groups) == 0:

                    # add Y0
                    mol_prop += float(self.group_data.loc[&#34;Yo&#34;, prop])

                    # propagate error of summed groups: sqrt(a**2 + b**2 + ...)
                    mol_err = round(math.sqrt(sum([float(err)**2 for err in prop_errs])), n_dec)

#                     # format output as string (preserves trailing zeros)
#                     mol_prop = format(mol_prop, &#39;.&#39;+str(n_dec)+&#39;f&#39;)
#                     mol_err = format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)

                    self.__setattr__(prop, mol_prop)
                    self.__setattr__(err_str, mol_err)

                else:
                    msg = self.name + &#34; encountered errors with group(s): &#34; +\
                        str(error_groups) + &#34;. Are these groups assigned &#34;+\
                        &#34;hydration properties in the data file?&#34;
                    self.err_handler.raise_exception(msg)
        
        ig_gas_error = False
        if self.Gig != None and self.Hig != None and self.Sig != None and self.Cpig != None:
            # no ideal gas estimation needed.
            # TODO: Modify if statement to allow calculating remainder if
            # two out of three are provided for: Gig, Hig, Sig
            pass
        else:
            # Joback estimation of the Gibbs free energy of formation of the
            # ideal gas (Joule-based).
            try:
                J_estimate = Joback(self.name)
                
                if self.Gig == None:
                    self.Gig = J_estimate[&#34;Gig&#34;]
                if self.Hig == None:
                    self.Hig = J_estimate[&#34;Hig&#34;]
                if self.Sig == None:
                    self.Sig = ((float(self.Gig) - float(self.Hig))/-298.15)*1000 + self.Selements
                if self.Cpig == None:
                    self.Cpig = J_estimate[&#34;Cpig&#34;]
            except:
                ig_gas_error = True

        if ig_gas_error:
            self.err_handler.raise_exception(&#34;The properties of aqueous &#34;+self.name+&#34; could not be &#34;
                &#34;estimated because its ideal gas properties could not be &#34;
                &#34;estimated with the Joback method.&#34;)
                
        # estimate the Gibbs free energy of formation of the aqueous molecule by summing
        # its ideal gas and hydration properties.
        # TODO: if ideal gas properties are NaN, ensure aqueous properties are too.
        # TODO: determine estimation error of ideal gas, then propagate with hydration errors.
        # TODO: propagate errors into HKF parameter estimations.
        
        try:
            if self.Gaq == None:
                self.Gaq = float(self.Gig) + float(self.Gh)
        except:
            self.Gaq = float(&#34;NaN&#34;)

        try:
            if self.Haq == None:
                self.Haq = float(self.Hig) + float(self.Hh)
        except:
            self.Haq = float(&#34;NaN&#34;)

        try:
            if self.Saq == None:
                self.Saq = ((float(self.Gaq) - float(self.Haq))/-298.15)*1000 + self.Selements
        except:
            self.Saq = float(&#34;NaN&#34;)
        try:
            if self.Cpaq == None:
                self.Cpaq = self.Cpig + float(self.Cph)
        except:
            self.Cpaq = float(&#34;NaN&#34;) 

        # calculate HKF parameters
        try:
            # find_HKF requires calories
            hkf_dict, eq = find_HKF(Gh=float(self.Gh)*1000/4.184,
                                    V=float(self.V),
                                    Cp=float(self.Cpaq)/4.184,
                                    Gf=float(self.Gaq)*1000/4.184,
                                    Hf=float(self.Haq)*1000/4.184,
                                    Saq=float(self.Saq)/4.184,
                                    Z=float(self.charge))

            properties_to_convert = [&#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]
            for k,v in zip(hkf_dict.keys(), hkf_dict.values()):
                if k in properties_to_convert:
                    hkf_dict[k] = v*4.184
                else:
                    hkf_dict[k] = v

            for param in [&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]:
                self.__setattr__(param, hkf_dict[param])

        except:
            print(&#34;Could not calculate HKF parameters for&#34;, self.name)
            pass

    # convert dataframe into an OBIGT table with an option to write to a csv file.
    def __convert_to_OBIGT(self):


        df_prop = {&#39;name&#39;:[self.name],
                   &#39;abbrv&#39;:[self.formula],
                   &#39;formula&#39;:[self.formula],
                   &#39;state&#39;:[&#39;aq&#39;],
                   &#39;ref1&#39;:[&#39;AqOrg&#39;],
                   &#39;ref2&#39;:[&#39;GrpAdd&#39;],
                   &#39;date&#39;:[datetime.now().strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)],
                   &#39;E_units&#39;:[&#39;J&#39;],
                   &#39;G&#39;:[float(self.Gaq)*1000],
                   &#39;H&#39;:[float(self.Haq)*1000],
                   &#39;S&#39;:[float(self.Saq)],
                   &#39;Cp&#39;:[float(self.Cpaq)],
                   &#39;V&#39;:[float(self.V)]}
        try:
            # if HKF parameters could be estimated
            df_hkf = {&#39;a1.a&#39;:[float(self.a1)],
                      &#39;a2.b&#39;:[float(self.a2)],
                      &#39;a3.c&#39;:[float(self.a3)],
                      &#39;a4.d&#39;:[float(self.a4)],
                      &#39;c1.e&#39;:[float(self.c1)],
                      &#39;c2.f&#39;:[float(self.c2)],
                      &#39;omega.lambda&#39;:[float(self.omega)],
                      &#39;z.T&#39;:[self.charge]}
        except:
            df_hkf = {&#39;a1.a&#39;:[float(&#34;NaN&#34;)],
                      &#39;a2.b&#39;:[float(&#34;NaN&#34;)],
                      &#39;a3.c&#39;:[float(&#34;NaN&#34;)],
                      &#39;a4.d&#39;:[float(&#34;NaN&#34;)],
                      &#39;c1.e&#39;:[float(&#34;NaN&#34;)],
                      &#39;c2.f&#39;:[float(&#34;NaN&#34;)],
                      &#39;omega.lambda&#39;:[float(&#34;NaN&#34;)],
                      &#39;z.T&#39;:[self.charge]}

        df_prop.update(df_hkf)
        
        df = pd.DataFrame(df_prop)
        
        return df

    def __estimate(self):
        self.__set_groups()
        self.__est_calcs()
        return self.__convert_to_OBIGT()

    def __estimate_joback(self):
        self.__set_groups()
        self.__est_joback()

def Joback(name):
    
    &#34;&#34;&#34;
    Estimate standard state ideal gas properties of a molecule using the Joback
    method. (Joback K. G., Reid R. C., &#34;Estimation of Pure-Component Properties
    from Group-Contributions&#34;, Chem. Eng. Commun., 57, 233–243, 1987.)
    
    Parameters
    ----------
    name : str
        Name of the molecule for which to estimate ideal gas properties.
        
    Returns
    ----------
    dict
        A dictionary containing standard state ideal gas properties estimated
        with the Joback method:
        
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
    &#34;&#34;&#34;
    
    ig_est = Estimate(name, state=&#39;gas&#39;, show=False,
                      group_data=pkg_resources.resource_stream(__name__, &#39;data/joback_groups.csv&#39;), index_col=&#34;groups&#34;)
    
    return {&#39;Gig&#39;:ig_est.Gig, &#39;Hig&#39;:ig_est.Hig,
            &#39;Sig&#39;:ig_est.Sig, &#39;Cpig&#39;:ig_est.Cpig}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="AqOrg.AqOrg.Joback"><code class="name flex">
<span>def <span class="ident">Joback</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate standard state ideal gas properties of a molecule using the Joback
method. (Joback K. G., Reid R. C., "Estimation of Pure-Component Properties
from Group-Contributions", Chem. Eng. Commun., 57, 233–243, 1987.)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the molecule for which to estimate ideal gas properties.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>A dictionary containing standard state ideal gas properties estimated
with the Joback method:</p>
<ul>
<li>Gig : Ideal gas Gibbs free energy of formation, kJ/mol.</li>
<li>Hig : Ideal gas enthalpy of formation, kJ/mol.</li>
<li>Sig : Ideal gas entropy, J/mol/K.</li>
<li>Cpig : Ideal gas isobaric heat capacity, J/mol/K.</li>
</ul>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Joback(name):
    
    &#34;&#34;&#34;
    Estimate standard state ideal gas properties of a molecule using the Joback
    method. (Joback K. G., Reid R. C., &#34;Estimation of Pure-Component Properties
    from Group-Contributions&#34;, Chem. Eng. Commun., 57, 233–243, 1987.)
    
    Parameters
    ----------
    name : str
        Name of the molecule for which to estimate ideal gas properties.
        
    Returns
    ----------
    dict
        A dictionary containing standard state ideal gas properties estimated
        with the Joback method:
        
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
    &#34;&#34;&#34;
    
    ig_est = Estimate(name, state=&#39;gas&#39;, show=False,
                      group_data=pkg_resources.resource_stream(__name__, &#39;data/joback_groups.csv&#39;), index_col=&#34;groups&#34;)
    
    return {&#39;Gig&#39;:ig_est.Gig, &#39;Hig&#39;:ig_est.Hig,
            &#39;Sig&#39;:ig_est.Sig, &#39;Cpig&#39;:ig_est.Cpig}</code></pre>
</details>
</dd>
<dt id="AqOrg.AqOrg.find_sigfigs"><code class="name flex">
<span>def <span class="ident">find_sigfigs</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the number of significant digits in a string representing a number up to
eight digits long.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code></dt>
<dd>A string denoting a number. This can include scientific notation.</dd>
</dl>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>int</code></strong></dt>
<dd>The number of significant digits.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;5.220&quot;)
4
</code></pre>
<p>This also takes into account scientific notation.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;1.23e+3&quot;)
3
</code></pre>
<p>Insignificant zeros are ignored.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;4000&quot;)
1
</code></pre>
<p>A decimal point denotes that zeros are significant.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;4000.&quot;)
4
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_sigfigs(x):
    
    &#39;&#39;&#39;
    Get the number of significant digits in a string representing a number up to
    eight digits long.

    Parameters
    ----------
    x : str
        A string denoting a number. This can include scientific notation.
    
    Parameters
    ----------
    int
        The number of significant digits.
    
    Examples
    --------
    &gt;&gt;&gt; find_sigfigs(&#34;5.220&#34;)
    4
    
    This also takes into account scientific notation.
    
    &gt;&gt;&gt; find_sigfigs(&#34;1.23e+3&#34;)
    3
    
    Insignificant zeros are ignored.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000&#34;)
    1
    
    A decimal point denotes that zeros are significant.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000.&#34;)
    4
    &#39;&#39;&#39;
    
    x = str(x)
    
    # change all the &#39;E&#39; to &#39;e&#39;
    x = x.lower()
    if (&#39;-&#39; == x[0]):
        x = x[1:]
    if (&#39;e&#39; in x):
        # return the length of the numbers before the &#39;e&#39;
        myStr = x.split(&#39;e&#39;)
        return len(myStr[0]) - 1  # to compenstate for the decimal point
    else:
        # put it in e format and return the result of that
        ### NOTE: because of the 8 below, it may do crazy things when it parses 9 sigfigs
        n = (&#39;%.*e&#39; % (8, float(x))).split(&#39;e&#39;)
        # remove and count the number of removed user added zeroes. (these are sig figs)
        if &#39;.&#39; in x:
            s = x.replace(&#39;.&#39;, &#39;&#39;)
            #number of zeroes to add back in
            l = len(s) - len(s.rstrip(&#39;0&#39;))
            #strip off the python added zeroes and add back in the ones the user added
            n[0] = n[0].rstrip(&#39;0&#39;) + &#39;&#39;.join([&#39;0&#39; for num in range(l)])
        else:
            #the user had no trailing zeroes so just strip them all
            n[0] = n[0].rstrip(&#39;0&#39;)
        #pass it back to the beginning to be parsed
    return find_sigfigs(&#39;e&#39;.join(n))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="AqOrg.AqOrg.Estimate"><code class="flex name class">
<span>class <span class="ident">Estimate</span></span>
<span>(</span><span>name, show=True, group_data=None, test=False, state='aq', save=False, hide_traceback=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate thermodynamic properties of an aqueous organic molecule.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the aqueous organic molecule that will have its thermodynamic
properties estimated.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a diagram of the molecule?</dd>
<dt><strong><code>group_data</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of a CSV containing custom group contribution data.</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Perform a simple group matching test instead of estimating properties?</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code>, default <code>"aq"</code></dt>
<dd>Can be "aq" or "gas". Estimate the properties of an aqueous molecule or
an ideal gas?</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Save molecular structure figures as PNG and SVG?</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>numeric</code> or <code>str</code>, optional</dt>
<dd>
<p>Known standard state partial molal thermodynamic properties at 298.15 K
and 1 bar. These will not be estimated, but instead will be used to
estimate other properties and parameters. Valid **kwargs include:</p>
<ul>
<li>Gh : Gibbs free energy change of hydration, kJ/mol.</li>
<li>Hh : Enthalpy change of hydration, kJ/mol.</li>
<li>Sh : Entropy change of hydration, J/mol/K.</li>
<li>Cph : Heat capacity change of hydration, J/mol/K.</li>
<li>V : Volume change of hydration, cm3/mol.</li>
<li>Gh_err : Error associated with Gh (default 0 kJ/mol).</li>
<li>Hh_err : Error associated with Hh (default 0 kJ/mol).</li>
<li>Sh_err : Error associated with Sh (default 0 J/mol/K).</li>
<li>Cph_err : Error associated with Cph (default 0 J/mol/K).</li>
<li>V_err : error associated with V (default 0 cm3/mol).</li>
<li>Gig : Ideal gas Gibbs free energy of formation, kJ/mol.</li>
<li>Hig : Ideal gas enthalpy of formation, kJ/mol.</li>
<li>Sig : Ideal gas entropy, J/mol/K.</li>
<li>Cpig : Ideal gas isobaric heat capacity, J/mol/K.</li>
<li>Gaq : Aqueous Gibbs free energy of formation, kJ/mol.</li>
<li>Haq : Aqueous enthalpy of formation, kJ/mol.</li>
<li>Saq : Aqueous entropy, J/mol/K.</li>
<li>Cpaq : Aqueous isobaric heat capacity, J/mol/K.</li>
</ul>
</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pcp_compound</code></strong> :&ensp;<code>pcp.get_compounds()</code></dt>
<dd>PubChemPy compound object.</dd>
<dt><strong><code>smiles</code></strong> :&ensp;<code>str</code></dt>
<dd>Canonical SMILES string.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Molecular formula.</dd>
<dt><strong><code>formula_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of element abundance in the molecular formula.</dd>
<dt><strong><code>element_data</code></strong> :&ensp;<code>pd.DataFrame()</code></dt>
<dd>Table of element data adapted from Jeff Dick's CHNOSZ package for R.</dd>
<dt><strong><code>Selements</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Sum of the contributions of the entropies of the elements according to
Cox, J. D., Wagman, D. D., &amp; Medvedev, V. A. (1989). CODATA key values
for thermodynamics. Chem/Mats-Sci/E.</dd>
<dt><strong><code>note</code></strong> :&ensp;<code>str</code></dt>
<dd>Notes and warnings associated with the estimation.</dd>
<dt><strong><code>charge</code></strong> :&ensp;<code>numeric</code></dt>
<dd>The charge of the molecule.</dd>
<dt><strong><code>OBIGT</code></strong> :&ensp;<code>pd.DataFrame()</code></dt>
<dd>Table of estimated thermodynamic properties and parameters. The format
is styled after Jeff Dick's OBIGT thermodynamic table in the CHNOSZ
package (see <a href="https://chnosz.net/manual/thermo.html">https://chnosz.net/manual/thermo.html</a>).</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this function?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Estimate():
    
    &#34;&#34;&#34;
    Estimate thermodynamic properties of an aqueous organic molecule.
    
    Parameters
    ----------
    name : str
        Name of the aqueous organic molecule that will have its thermodynamic
        properties estimated.
                       
    show : bool, default True
        Show a diagram of the molecule?
    
    group_data : str, optional
        Name of a CSV containing custom group contribution data.
    
    test : bool, default False
        Perform a simple group matching test instead of estimating properties?

    state : str, default &#34;aq&#34;
        Can be &#34;aq&#34; or &#34;gas&#34;. Estimate the properties of an aqueous molecule or
        an ideal gas?

    save : bool, default False
        Save molecular structure figures as PNG and SVG?
    
    **kwargs : numeric or str, optional
        Known standard state partial molal thermodynamic properties at 298.15 K
        and 1 bar. These will not be estimated, but instead will be used to
        estimate other properties and parameters. Valid **kwargs include:
        
        - Gh : Gibbs free energy change of hydration, kJ/mol.
        - Hh : Enthalpy change of hydration, kJ/mol.
        - Sh : Entropy change of hydration, J/mol/K.
        - Cph : Heat capacity change of hydration, J/mol/K.
        - V : Volume change of hydration, cm3/mol.
        - Gh_err : Error associated with Gh (default 0 kJ/mol).
        - Hh_err : Error associated with Hh (default 0 kJ/mol).
        - Sh_err : Error associated with Sh (default 0 J/mol/K).
        - Cph_err : Error associated with Cph (default 0 J/mol/K).
        - V_err : error associated with V (default 0 cm3/mol).
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
        - Gaq : Aqueous Gibbs free energy of formation, kJ/mol.
        - Haq : Aqueous enthalpy of formation, kJ/mol.
        - Saq : Aqueous entropy, J/mol/K.
        - Cpaq : Aqueous isobaric heat capacity, J/mol/K.
    
    Attributes
    ----------
    pcp_compound : pcp.get_compounds()
        PubChemPy compound object.
        
    smiles : str
        Canonical SMILES string.
        
    formula : str
        Molecular formula.
        
    formula_dict : dict
        Dictionary of element abundance in the molecular formula.
        
    element_data : pd.DataFrame()
        Table of element data adapted from Jeff Dick&#39;s CHNOSZ package for R.
        
    Selements : numeric
        Sum of the contributions of the entropies of the elements according to
        Cox, J. D., Wagman, D. D., &amp; Medvedev, V. A. (1989). CODATA key values
        for thermodynamics. Chem/Mats-Sci/E.
        
    note : str
        Notes and warnings associated with the estimation.
        
    charge : numeric
        The charge of the molecule.
        
    OBIGT : pd.DataFrame()
        Table of estimated thermodynamic properties and parameters. The format
        is styled after Jeff Dick&#39;s OBIGT thermodynamic table in the CHNOSZ
        package (see https://chnosz.net/manual/thermo.html).

    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this function?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    
    def __init__(self, name, show=True, group_data=None,
                       test=False, state=&#39;aq&#39;, save=False, hide_traceback=True,
                       **kwargs):
                       # E_units=&#34;J&#34; # not implemented... tricky because groups
                                     # are in both kJ and J units.

        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.name = name
        
        # valid kwargs
        self.Gh = None
        self.Hh = None
        self.Sh = None
        self.Cph = None
        self.V = None
        self.Gh_err = 0
        self.Hh_err = 0
        self.Sh_err = 0
        self.Cph_err = 0
        self.V_err = 0
        self.Gig = None
        self.Hig = None
        self.Sig = None
        self.Cpig_a = None
        self.Cpig_b = None
        self.Cpig_c = None
        self.Cpig_d = None
        self.Cpig = None
        self.Gaq = None
        self.Haq = None
        self.Saq = None
        self.Cpaq = None

        for key, value in kwargs.items():
            self.__setattr__(key, value)
        
        # load group contribution data
        if group_data == None:
            if state == &#34;aq&#34;:
                group_data = pkg_resources.resource_stream(__name__, &#34;data/group_contribution_data.csv&#34;)
            elif state == &#34;gas&#34;:
                group_data=pkg_resources.resource_stream(__name__, &#39;data/joback_groups.csv&#39;)
            else:
                self.err_handler.raise_exception(&#34;State is unrecognized. Must be either &#39;aq&#39; or &#39;gas&#39;.&#34;)
        self.__load_group_data(group_data)
        
        # look up compound on PubChem
        self.pcp_compound = pcp.get_compounds(self.name, &#34;name&#34;)
        if len(self.pcp_compound) == 0:
            self.err_handler.raise_exception(&#34;Could not find &#39;&#34; + self.name + &#34;&#39; in PubChem&#39;s online database.&#34;)
        self.smiles = self.pcp_compound[0].canonical_smiles
        self.formula = self.pcp_compound[0].molecular_formula
        self.formula_dict = parse_formula(self.formula)
        
        if &#34;-&#34; in self.formula_dict.keys() or &#34;+&#34; in self.formula_dict.keys():
            self.err_handler.raise_exception(self.name + &#34; cannot be estimated because it has a net charge.&#34;)

        if show:
            self.__display_molecule(save=save)

        if test:
            print(self.__test_group_match())            
        else:
            # load properties of the elements
            # Cox, J. D., Wagman, D. D., and Medvedev, V. A., CODATA Key Values
            # for Thermodynamics, Hemisphere Publishing Corp., New York, 1989.
            # Compiled into a CSV by Jeffrey Dick for CHNOSZ
            element_data = pd.read_csv(pkg_resources.resource_stream(__name__, &#39;data/element.csv&#39;), index_col=&#34;element&#34;)
            self.element_data = element_data.loc[element_data[&#39;source&#39;] == &#34;CWM89&#34;]
            
            self.Selements = self.__entropy()
            self.note = &#34;&#34;
            self.charge = 0 # !
            
            if state == &#39;aq&#39;:
                self.OBIGT = self.__estimate()
            elif state == &#39;gas&#39;:
                self.__estimate_joback()

    def __load_group_data(self, db_filename):
        self.group_data = pd.read_csv(db_filename, dtype=str)
        self.group_data[&#39;elem&#39;] = self.group_data[&#39;elem&#39;].fillna(&#39;&#39;)
        self.pattern_dict = pd.Series(self.group_data[&#34;elem&#34;].values,
                                      index=self.group_data[&#34;smarts&#34;]).to_dict()
        self.group_data = self.group_data.set_index(&#34;smarts&#34;)

        
    def __set_groups(self):
        
        self.group_matches = pd.DataFrame(self.__match_groups(), index=[self.name])

        # remove columns with no matches
        self.group_matches = self.group_matches.loc[:, (self.group_matches.sum(axis=0) != 0)]
        
        # get a list of relevent groups
        self.groups = [grp for grp in self.group_matches.columns if grp != &#34;formula&#34;]
        

    def __entropy(self, unit=&#34;J/mol/K&#34;):
        
        &#34;&#34;&#34;
        Calculate the standard molal entropy of elements in a molecule.
        &#34;&#34;&#34;

        entropies = [(self.element_data.loc[elem, &#34;s&#34;]/self.element_data.loc[elem, &#34;n&#34;])*self.formula_dict[elem] for elem in list(self.formula_dict.keys())]
        if unit == &#34;J/mol/K&#34;:
            unit_conv = 4.184
        elif unit == &#34;cal/mol/K&#34;:
            unit_conv = 1
        else:
            print(&#34;Warning in entropy: specified unit&#34;, unit,
                  &#34;is not recognized. Returning entropy in J/mol/K&#34;)
            unit_conv = 4.184
            
        return sum(entropies)*unit_conv

    
    def __dict_to_formula(self, formula_dict):
        
        &#34;&#34;&#34;
        Convert a formula dictionary into a formula string.
        Example:
        ```dict_to_formula(parse_formula(&#34;CO3-2&#34;))```
        &#34;&#34;&#34;
        
        formula_string = &#34;&#34;
        for key in formula_dict.keys():
            if abs(formula_dict[key]) == 1:
                v = &#34;&#34;
            else:
                v = formula_dict[key]
                if (v).is_integer():
                    v = int(v)

            formula_string = formula_string + str(key) + str(v)
        return formula_string

    
    def __match_groups(self, show=False, save=False):
        patterns = self.pattern_dict.keys()
        mol = Chem.MolFromSmiles(self.smiles)

        match_dict = dict(zip(patterns, [0]*len(patterns))) # initialize match_dict
        for pattern in patterns:
            if pattern != &#34;Yo&#34;: # never match material point
                try:
                    match_dict[pattern] = len(mol.GetSubstructMatches(Chem.MolFromSmarts(pattern)))
                except:
                    print(&#34;Warning in match_groups(): problem&#34;,
                          &#34;identifying SMARTS group&#34;, pattern,
                          &#34;. Skipping this group.&#34;)

        ### check that total formula of groups matches that of the molecule
        
        # create a dictionary of element matches
        total_formula_dict = {}
        for match in match_dict.keys():
            this_match = parse_formula(self.pattern_dict[match])
            for element in this_match.keys():
                this_match[element] *= match_dict[match]
                if element in total_formula_dict:
                    total_formula_dict[element] += this_match[element]
                else:
                    total_formula_dict[str(element)] = 0
                    total_formula_dict[element] += this_match[element]
        
        # remove keys of elements with a value of 0 (e.g. &#34;H&#34;:0.0)
        for key in list(total_formula_dict.keys()):
            if total_formula_dict[key] == 0.0:
                total_formula_dict.pop(key, None)
        
        # retrieve individual charges that contribute to net charge
        atomic_info = self.pcp_compound[0].record[&#34;atoms&#34;]
        chargedict = {}
        if &#34;charge&#34; in atomic_info.keys():
            all_charges = [chargedict.get(&#34;value&#34;, 0) for chargedict in atomic_info[&#34;charge&#34;]]
            pos_charge = sum([charge for charge in all_charges if charge &gt; 0])
            neg_charge = abs(sum([charge for charge in all_charges if charge &lt; 0]))
            if pos_charge &gt; 0:
                chargedict[&#39;+&#39;]=float(pos_charge)
            if neg_charge &gt; 0:
                chargedict[&#39;-&#39;]=float(neg_charge)
        else:
            chargedict = {}

        # perform the comparison
        test_dict = parse_formula(self.pcp_compound[0].molecular_formula)
        test_dict.update(chargedict)
        if total_formula_dict != test_dict:
            mssg = &#34;The formula of &#34; + self.name + \
                &#34; does not equal the the elemental composition of the &#34; + \
                &#34;matched groups. This could be because the database &#34; + \
                &#34;is missing representative groups.\nFormula of &#34; + \
                self.name + &#34;:\n&#34;
            pcp_dict = parse_formula(self.pcp_compound[0].molecular_formula)
            pcp_dict.update(chargedict)
            mssg = mssg + str(pcp_dict) + &#34;\nTotal formula of group matches:\n&#34; + \
                str(total_formula_dict)
            mssg = mssg + &#34;\nIncomplete group matches:\n&#34; + \
                str({k:v for k,v in zip(match_dict.keys(), match_dict.values()) if v!= 0})
            self.err_handler.raise_exception(mssg)
        
        # add molecular formula to match dictionary
        match_dict[&#34;formula&#34;] = self.__dict_to_formula(total_formula_dict)
        
        return match_dict

    
    def __display_molecule(self, show=True, save=False):
        mol_smiles = Chem.MolFromSmiles(self.smiles)
        
        mc = Chem.Mol(mol_smiles.ToBinary())
        molSize=(450, 150)
        
        if not mc.GetNumConformers():
            #Compute 2D coordinates
            rdDepictor.Compute2DCoords(mc)
        # init the drawer with the size
        drawer = rdMolDraw2D.MolDraw2DSVG(molSize[0],molSize[1])
        #draw the molcule
        drawer.DrawMolecule(mc)
        drawer.FinishDrawing()
        # get the SVG string
        svg = drawer.GetDrawingText()

        if show:
            # fix the svg string and display it
            display(SVG(svg.replace(&#39;svg:&#39;,&#39;&#39;)))

        if save:
            os.makedirs(&#34;mol_svg&#34;, exist_ok=True)
            os.makedirs(&#34;mol_png&#34;, exist_ok=True)
            #Draw.MolToFile( mol, &#34;mol_svg/&#34;+self.name+&#34;.svg&#34; )
            Draw.MolToFile(mol_smiles, &#34;mol_png/&#34;+self.name+&#34;.png&#34;)


    def __test_group_match(self):
        match_dict = self.__match_groups()
        return {key:value for key,value in zip(match_dict.keys(), match_dict.values()) if value !=0}

    
    def __est_joback(self):
        
        # values to be added to final estimate of each property
        joback_props = {&#34;Gig&#34;:53.88, &#34;Hig&#34;:68.29, # kJ/mol
                        &#34;Cpig_a&#34;:-37.93, &#34;Cpig_b&#34;:0.210, # j/mol/K
                        &#34;Cpig_c&#34;:-3.91*10**-4, &#34;Cpig_d&#34;:2.06*10**-7} # j/mol/K
        
        for prop in joback_props.keys():
            mol_prop = 0
            error_groups = []

            for group in self.groups:

                try:
                    contains_group = self.group_matches.loc[self.name, group][0] != 0
                except:
                    contains_group = self.group_matches.loc[self.name, group] != 0

                # if this molecule contains this group...
                if contains_group:
                    try:
                        # add number of groups multiplied by its contribution
                        mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])
                    except:
                        error_groups.append(group)
                        
                if len(error_groups) == 0:
                    self.__setattr__(prop, mol_prop+joback_props[prop])
                else:
                    self.err_handler.raise_exception(&#34;&#34; + self.name + &#34; encountered errors with group(s): &#34;
                        &#34;&#34;+str(error_groups) + &#34;. Are these groups assigned &#34;
                        &#34;ideal gas properties in the Joback data file?&#34;)
            
        # calculate Cpig
        T=298.15
        self.Cpig = self.Cpig_a + self.Cpig_b*T + self.Cpig_c*T**2 +\
                    self.Cpig_d*T**3
        
        # calculate Sig
        self.Sig = ((self.Gig - self.Hig)/-298.15)*1000 + self.Selements
    
    
    def __est_calcs(self):

        props = [&#34;Gh&#34;, &#34;Hh&#34;, &#34;Sh&#34;, &#34;Cph&#34;, &#34;V&#34;]
        
        for prop in props:
            if self.__getattribute__(prop) == None:
                err_str = prop + &#34;_err&#34;

                # derive Sh, entropy of hydration, in J/mol K
                if prop == &#34;Sh&#34;:
                    # Entropy calculated from S = (G-H)/(-Tref)
                    mol_prop = (float(self.Gh) - float(self.Hh))/(-298.15)
                    mol_prop = mol_prop*1000 # convert kJ/molK to J/molK

                    # propagate error from Gh and Hh to estimate Sh error.
                    # equation used: Sh_err = Sh*sqrt((Gh_err/Gh)**2 + (Hh_err/Hh)**2)
                    Gh_err_float = float(self.Gh_err)/float(self.Gh)
                    Hh_err_float = float(self.Hh_err)/float(self.Hh)
                    mol_err = abs(mol_prop)*math.sqrt(Gh_err_float**2 + Hh_err_float**2)

                    # check whether Gh or Hh as the fewest sigfigs
                    sf = min([find_sigfigs(self.Gh), find_sigfigs(self.Hh)])

                    # round Sh to this number of sigfigs
                    mol_prop = sigfig.round(str(mol_prop), sigfigs=sf)

                    # check how many decimal places Sh has after sigfig rounding
                    if &#34;.&#34; in mol_prop:
                        this_split = mol_prop.split(&#34;.&#34;)
                        n_dec = len(this_split[len(this_split)-1])
                    else:
                        n_dec = 0

                    # assign Sh and Sh_err
                    #self.__setattr__(prop, mol_prop) # for trailing zeros, but must store Sh as str.
                    #self.__setattr__(err_str, format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)) # for trailing zeros, but must store Sh_err as str.
                    self.__setattr__(prop, float(mol_prop))
                    self.__setattr__(err_str, round(float(mol_err), n_dec))


                    continue

                # For all properties except for Sh:
                # initialize variables and lists
                mol_prop = 0
                mol_err = 999
                prop_errs = []
                n_dec = 999
                error_groups = []

                for group in self.groups:

                    try:
                        contains_group = self.group_matches.loc[self.name, group][0] != 0
                    except:
                        contains_group = self.group_matches.loc[self.name, group] != 0

                    # if this molecule contains this group...
                    if contains_group:

                        try:
                            # add number of groups multiplied by its contribution
                            mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])

                            # round property to smallest number of decimal places
                            if &#34;.&#34; in self.group_data.loc[group, prop]:
                                this_split = self.group_data.loc[group, prop].split(&#34;.&#34;)
                                n_dec_group = len(this_split[len(this_split)-1])
                            else:
                                n_dec_group = 0

                            if n_dec_group &lt; n_dec:
                                n_dec = n_dec_group

                            # handle group std errors
                            try:
                                float(self.group_data.loc[group, err_str]) # assert that this group&#39;s error is numeric
                                prop_errs.append(self.group_data.loc[group, err_str]) # append error
                            except:
                                # if group&#39;s error is non-numeric, pass
                                pass

                        except:
                            error_groups.append(group)

                if len(error_groups) == 0:

                    # add Y0
                    mol_prop += float(self.group_data.loc[&#34;Yo&#34;, prop])

                    # propagate error of summed groups: sqrt(a**2 + b**2 + ...)
                    mol_err = round(math.sqrt(sum([float(err)**2 for err in prop_errs])), n_dec)

#                     # format output as string (preserves trailing zeros)
#                     mol_prop = format(mol_prop, &#39;.&#39;+str(n_dec)+&#39;f&#39;)
#                     mol_err = format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)

                    self.__setattr__(prop, mol_prop)
                    self.__setattr__(err_str, mol_err)

                else:
                    msg = self.name + &#34; encountered errors with group(s): &#34; +\
                        str(error_groups) + &#34;. Are these groups assigned &#34;+\
                        &#34;hydration properties in the data file?&#34;
                    self.err_handler.raise_exception(msg)
        
        ig_gas_error = False
        if self.Gig != None and self.Hig != None and self.Sig != None and self.Cpig != None:
            # no ideal gas estimation needed.
            # TODO: Modify if statement to allow calculating remainder if
            # two out of three are provided for: Gig, Hig, Sig
            pass
        else:
            # Joback estimation of the Gibbs free energy of formation of the
            # ideal gas (Joule-based).
            try:
                J_estimate = Joback(self.name)
                
                if self.Gig == None:
                    self.Gig = J_estimate[&#34;Gig&#34;]
                if self.Hig == None:
                    self.Hig = J_estimate[&#34;Hig&#34;]
                if self.Sig == None:
                    self.Sig = ((float(self.Gig) - float(self.Hig))/-298.15)*1000 + self.Selements
                if self.Cpig == None:
                    self.Cpig = J_estimate[&#34;Cpig&#34;]
            except:
                ig_gas_error = True

        if ig_gas_error:
            self.err_handler.raise_exception(&#34;The properties of aqueous &#34;+self.name+&#34; could not be &#34;
                &#34;estimated because its ideal gas properties could not be &#34;
                &#34;estimated with the Joback method.&#34;)
                
        # estimate the Gibbs free energy of formation of the aqueous molecule by summing
        # its ideal gas and hydration properties.
        # TODO: if ideal gas properties are NaN, ensure aqueous properties are too.
        # TODO: determine estimation error of ideal gas, then propagate with hydration errors.
        # TODO: propagate errors into HKF parameter estimations.
        
        try:
            if self.Gaq == None:
                self.Gaq = float(self.Gig) + float(self.Gh)
        except:
            self.Gaq = float(&#34;NaN&#34;)

        try:
            if self.Haq == None:
                self.Haq = float(self.Hig) + float(self.Hh)
        except:
            self.Haq = float(&#34;NaN&#34;)

        try:
            if self.Saq == None:
                self.Saq = ((float(self.Gaq) - float(self.Haq))/-298.15)*1000 + self.Selements
        except:
            self.Saq = float(&#34;NaN&#34;)
        try:
            if self.Cpaq == None:
                self.Cpaq = self.Cpig + float(self.Cph)
        except:
            self.Cpaq = float(&#34;NaN&#34;) 

        # calculate HKF parameters
        try:
            # find_HKF requires calories
            hkf_dict, eq = find_HKF(Gh=float(self.Gh)*1000/4.184,
                                    V=float(self.V),
                                    Cp=float(self.Cpaq)/4.184,
                                    Gf=float(self.Gaq)*1000/4.184,
                                    Hf=float(self.Haq)*1000/4.184,
                                    Saq=float(self.Saq)/4.184,
                                    Z=float(self.charge))

            properties_to_convert = [&#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]
            for k,v in zip(hkf_dict.keys(), hkf_dict.values()):
                if k in properties_to_convert:
                    hkf_dict[k] = v*4.184
                else:
                    hkf_dict[k] = v

            for param in [&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]:
                self.__setattr__(param, hkf_dict[param])

        except:
            print(&#34;Could not calculate HKF parameters for&#34;, self.name)
            pass

    # convert dataframe into an OBIGT table with an option to write to a csv file.
    def __convert_to_OBIGT(self):


        df_prop = {&#39;name&#39;:[self.name],
                   &#39;abbrv&#39;:[self.formula],
                   &#39;formula&#39;:[self.formula],
                   &#39;state&#39;:[&#39;aq&#39;],
                   &#39;ref1&#39;:[&#39;AqOrg&#39;],
                   &#39;ref2&#39;:[&#39;GrpAdd&#39;],
                   &#39;date&#39;:[datetime.now().strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)],
                   &#39;E_units&#39;:[&#39;J&#39;],
                   &#39;G&#39;:[float(self.Gaq)*1000],
                   &#39;H&#39;:[float(self.Haq)*1000],
                   &#39;S&#39;:[float(self.Saq)],
                   &#39;Cp&#39;:[float(self.Cpaq)],
                   &#39;V&#39;:[float(self.V)]}
        try:
            # if HKF parameters could be estimated
            df_hkf = {&#39;a1.a&#39;:[float(self.a1)],
                      &#39;a2.b&#39;:[float(self.a2)],
                      &#39;a3.c&#39;:[float(self.a3)],
                      &#39;a4.d&#39;:[float(self.a4)],
                      &#39;c1.e&#39;:[float(self.c1)],
                      &#39;c2.f&#39;:[float(self.c2)],
                      &#39;omega.lambda&#39;:[float(self.omega)],
                      &#39;z.T&#39;:[self.charge]}
        except:
            df_hkf = {&#39;a1.a&#39;:[float(&#34;NaN&#34;)],
                      &#39;a2.b&#39;:[float(&#34;NaN&#34;)],
                      &#39;a3.c&#39;:[float(&#34;NaN&#34;)],
                      &#39;a4.d&#39;:[float(&#34;NaN&#34;)],
                      &#39;c1.e&#39;:[float(&#34;NaN&#34;)],
                      &#39;c2.f&#39;:[float(&#34;NaN&#34;)],
                      &#39;omega.lambda&#39;:[float(&#34;NaN&#34;)],
                      &#39;z.T&#39;:[self.charge]}

        df_prop.update(df_hkf)
        
        df = pd.DataFrame(df_prop)
        
        return df

    def __estimate(self):
        self.__set_groups()
        self.__est_calcs()
        return self.__convert_to_OBIGT()

    def __estimate_joback(self):
        self.__set_groups()
        self.__est_joback()</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="AqOrg" href="index.html">AqOrg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="AqOrg.AqOrg.Joback" href="#AqOrg.AqOrg.Joback">Joback</a></code></li>
<li><code><a title="AqOrg.AqOrg.find_sigfigs" href="#AqOrg.AqOrg.find_sigfigs">find_sigfigs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="AqOrg.AqOrg.Estimate" href="#AqOrg.AqOrg.Estimate">Estimate</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>