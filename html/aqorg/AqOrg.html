<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>aqorg.AqOrg API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aqorg.AqOrg</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aqorg.AqOrg.Joback"><code class="name flex">
<span>def <span class="ident">Joback</span></span>(<span>name, smiles=None, group_data=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Joback(name, smiles=None, group_data=None):
    
    &#34;&#34;&#34;
    Estimate standard state ideal gas properties of a molecule using the Joback
    method. (Joback K. G., Reid R. C., &#34;Estimation of Pure-Component Properties
    from Group-Contributions&#34;, Chem. Eng. Commun., 57, 233–243, 1987.)
    
    Parameters
    ----------
    name : str
        Name of the molecule for which to estimate ideal gas properties.

    smiles : str, optional
        A SMILES string representing the molecule.

    group_data : str, optional
        Path of a CSV containing custom Joback group property data.
        
    Returns
    ----------
    dict
        A dictionary containing standard state ideal gas properties estimated
        with the Joback method:
        
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
    &#34;&#34;&#34;
    if group_data is None:
        with import_package_file(__name__, &#39;data/joback_groups.csv&#39;, as_file=True) as path:
            group_data = pd.read_csv(path, dtype=str)
    
    ig_est = Estimate(name, smiles=smiles, state=&#39;gas&#39;, ig_method=&#34;Joback&#34;, show=False,
                      group_data=group_data, index_col=&#34;groups&#34;)
    
    return {&#39;Gig&#39;:ig_est.Gig, &#39;Hig&#39;:ig_est.Hig,
            &#39;Sig&#39;:ig_est.Sig, &#39;Cpig&#39;:ig_est.Cpig}</code></pre>
</details>
<div class="desc"><p>Estimate standard state ideal gas properties of a molecule using the Joback
method. (Joback K. G., Reid R. C., "Estimation of Pure-Component Properties
from Group-Contributions", Chem. Eng. Commun., 57, 233–243, 1987.)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the molecule for which to estimate ideal gas properties.</dd>
<dt><strong><code>smiles</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A SMILES string representing the molecule.</dd>
<dt><strong><code>group_data</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path of a CSV containing custom Joback group property data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>A dictionary containing standard state ideal gas properties estimated
with the Joback method:</p>
<ul>
<li>Gig : Ideal gas Gibbs free energy of formation, kJ/mol.</li>
<li>Hig : Ideal gas enthalpy of formation, kJ/mol.</li>
<li>Sig : Ideal gas entropy, J/mol/K.</li>
<li>Cpig : Ideal gas isobaric heat capacity, J/mol/K.</li>
</ul>
</dd>
</dl></div>
</dd>
<dt id="aqorg.AqOrg.find_sigfigs"><code class="name flex">
<span>def <span class="ident">find_sigfigs</span></span>(<span>x)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_sigfigs(x):
    
    &#39;&#39;&#39;
    Get the number of significant digits in a string representing a number up to
    eight digits long.

    Parameters
    ----------
    x : str
        A string denoting a number. This can include scientific notation.
    
    Examples
    --------
    &gt;&gt;&gt; find_sigfigs(&#34;5.220&#34;)
    4
    
    This also takes into account scientific notation.
    
    &gt;&gt;&gt; find_sigfigs(&#34;1.23e+3&#34;)
    3
    
    Insignificant zeros are ignored.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000&#34;)
    1
    
    A decimal point denotes that zeros are significant.
    
    &gt;&gt;&gt; find_sigfigs(&#34;4000.&#34;)
    4
    &#39;&#39;&#39;
    
    x = str(x)
    
    # change all the &#39;E&#39; to &#39;e&#39;
    x = x.lower()
    if (&#39;-&#39; == x[0]):
        x = x[1:]
    if (&#39;e&#39; in x):
        # return the length of the numbers before the &#39;e&#39;
        myStr = x.split(&#39;e&#39;)
        return len(myStr[0]) - 1  # to compenstate for the decimal point
    else:
        # put it in e format and return the result of that
        ### NOTE: because of the 8 below, it may do crazy things when it parses 9 sigfigs
        n = (&#39;%.*e&#39; % (8, float(x))).split(&#39;e&#39;)
        # remove and count the number of removed user added zeroes. (these are sig figs)
        if &#39;.&#39; in x:
            s = x.replace(&#39;.&#39;, &#39;&#39;)
            #number of zeroes to add back in
            l = len(s) - len(s.rstrip(&#39;0&#39;))
            #strip off the python added zeroes and add back in the ones the user added
            n[0] = n[0].rstrip(&#39;0&#39;) + &#39;&#39;.join([&#39;0&#39; for num in range(l)])
        else:
            #the user had no trailing zeroes so just strip them all
            n[0] = n[0].rstrip(&#39;0&#39;)
        #pass it back to the beginning to be parsed
    return find_sigfigs(&#39;e&#39;.join(n))</code></pre>
</details>
<div class="desc"><p>Get the number of significant digits in a string representing a number up to
eight digits long.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>str</code></dt>
<dd>A string denoting a number. This can include scientific notation.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;5.220&quot;)
4
</code></pre>
<p>This also takes into account scientific notation.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;1.23e+3&quot;)
3
</code></pre>
<p>Insignificant zeros are ignored.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;4000&quot;)
1
</code></pre>
<p>A decimal point denotes that zeros are significant.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; find_sigfigs(&quot;4000.&quot;)
4
</code></pre></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aqorg.AqOrg.Estimate"><code class="flex name class">
<span>class <span class="ident">Estimate</span></span>
<span>(</span><span>name=None,<br>smiles=None,<br>show=True,<br>group_data=None,<br>test=False,<br>state='aq',<br>ig_method='Joback',<br>save=False,<br>hide_traceback=True,<br>**kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Estimate():
    
    &#34;&#34;&#34;
    Estimate thermodynamic properties of an aqueous organic molecule.
    
    Parameters
    ----------
    name : str, optional
        Name of the aqueous organic molecule that will have its thermodynamic
        properties estimated.

    smiles : str, optional
        A SMILES string representing the molecule.
                       
    show : bool, default True
        Show a diagram of the molecule?
    
    group_data : str, optional
        Path of a CSV containing custom group contribution data. If `state=&#34;aq&#34;`
        then the CSV should contain hydration properties. If `state=&#34;gas&#34;` then
        the CSV should contain ideal gas properties.
    
    test : bool, default False
        Perform a simple group matching test instead of estimating properties?

    state : str, default &#34;aq&#34;
        Can be &#34;aq&#34; or &#34;gas&#34;. Estimate the properties of an aqueous molecule or
        an ideal gas?

    ig_method : str, default &#34;Joback&#34;
        Method used to estimate ideal gas properties.

    save : bool, default False
        Save molecular structure figures as PNG and SVG?
    
    **kwargs : numeric or str, optional
        Known standard state partial molal thermodynamic properties at 298.15 K
        and 1 bar. These will not be estimated, but instead will be used to
        estimate other properties and parameters. Valid **kwargs include:
        
        - Gh : Gibbs free energy change of hydration, kJ/mol.
        - Hh : Enthalpy change of hydration, kJ/mol.
        - Sh : Entropy change of hydration, J/mol/K.
        - Cph : Heat capacity change of hydration, J/mol/K.
        - V : Volume change of hydration, cm3/mol.
        - Gh_err : Error associated with Gh (default 0 kJ/mol).
        - Hh_err : Error associated with Hh (default 0 kJ/mol).
        - Sh_err : Error associated with Sh (default 0 J/mol/K).
        - Cph_err : Error associated with Cph (default 0 J/mol/K).
        - V_err : error associated with V (default 0 cm3/mol).
        - Gig : Ideal gas Gibbs free energy of formation, kJ/mol.
        - Hig : Ideal gas enthalpy of formation, kJ/mol.
        - Sig : Ideal gas entropy, J/mol/K.
        - Cpig : Ideal gas isobaric heat capacity, J/mol/K.
        - Gaq : Aqueous Gibbs free energy of formation, kJ/mol.
        - Haq : Aqueous enthalpy of formation, kJ/mol.
        - Saq : Aqueous entropy, J/mol/K.
        - Cpaq : Aqueous isobaric heat capacity, J/mol/K.
    
    Attributes
    ----------
    pcp_compound : pcp.get_compounds()
        PubChemPy compound object.
        
    smiles : str
        Canonical SMILES string.
        
    formula : str
        Molecular formula.
        
    formula_dict : dict
        Dictionary of element abundance in the molecular formula.
        
    element_data : pd.DataFrame()
        Table of element data adapted from Jeff Dick&#39;s CHNOSZ package for R.
        
    Selements : numeric
        Sum of the contributions of the entropies of the elements according to
        Cox, J. D., Wagman, D. D., &amp; Medvedev, V. A. (1989). CODATA key values
        for thermodynamics. Chem/Mats-Sci/E.
        
    note : str
        Notes and warnings associated with the estimation.
        
    charge : numeric
        The charge of the molecule.
        
    OBIGT : pd.DataFrame()
        Table of estimated thermodynamic properties and parameters. The format
        is styled after Jeff Dick&#39;s OBIGT thermodynamic table in the CHNOSZ
        package (see https://chnosz.net/manual/thermo.html).

    hide_traceback : bool, default True
        Hide traceback message when encountering errors handled by this function?
        When True, error messages handled by this class will be short and to
        the point.
    
    &#34;&#34;&#34;
    
    def __init__(self, name=None, smiles=None, show=True, group_data=None,
                       test=False, state=&#39;aq&#39;, ig_method=&#34;Joback&#34;,
                       save=False, hide_traceback=True, **kwargs):
                       # E_units=&#34;J&#34; # not implemented... tricky because groups
                                     # are in both kJ and J units.

        self.err_handler = Error_Handler(clean=hide_traceback)
        
        self.name = name
        self.smiles = smiles
        self.state = state
        self.ig_method = ig_method
        
        # valid kwargs
        self.Gh = None
        self.Hh = None
        self.Sh = None
        self.Cph = None
        self.V = None
        self.Gh_err = 0
        self.Hh_err = 0
        self.Sh_err = 0
        self.Cph_err = 0
        self.V_err = 0
        self.Gig = None
        self.Hig = None
        self.Sig = None
        self.Cpig_a = None
        self.Cpig_b = None
        self.Cpig_c = None
        self.Cpig_d = None
        self.Cpig = None
        self.Gaq = None
        self.Haq = None
        self.Saq = None
        self.Cpaq = None

        for key, value in kwargs.items():
            self.__setattr__(key, value)
        
        self.group_data = group_data
        self.load_group_data()
        self.get_mol_smiles_formula_formula_dict()
        
        if &#34;-&#34; in self.formula_dict.keys() or &#34;+&#34; in self.formula_dict.keys():
            self.err_handler.raise_exception(self.name + &#34; cannot be estimated because it has a net charge.&#34;)

        if show:
            self.display_molecule(save=save)
            
        if test:
            print(self.__test_group_match())            
        else:
            # load properties of the elements
            # Cox, J. D., Wagman, D. D., and Medvedev, V. A., CODATA Key Values
            # for Thermodynamics, Hemisphere Publishing Corp., New York, 1989.
            # Compiled into a CSV by Jeffrey Dick for CHNOSZ

            with import_package_file(__name__, &#39;data/element.csv&#39;, as_file=True) as path:
                element_data = pd.read_csv(path, index_col=&#34;element&#34;)
            
            self.element_data = element_data.loc[element_data[&#39;source&#39;] == &#34;CWM89&#34;]
            
            self.Selements = self.__entropy()
            self.note = &#34;&#34;
            self.charge = 0 # !
            
            if state == &#39;aq&#39;:
                self.OBIGT = self.__estimate_hydration()
            elif state == &#39;gas&#39;:
                if ig_method == &#34;Joback&#34;:
                    self.__estimate_joback()
                else:
                    self.__estimate_ig()
            else:
                self.err_handler.raise_exception(&#34;State must be &#39;aq&#39; or &#39;gas&#39;.&#34;)

    def get_mol_smiles_formula_formula_dict(self):
        if not isinstance(self.smiles, str):
            # look up compound on PubChem
            self.pcp_compound = pcp.get_compounds(self.name, &#34;name&#34;)
            if len(self.pcp_compound) == 0:
                self.err_handler.raise_exception(&#34;Could not find &#39;&#34; + self.name + &#34;&#39; in PubChem&#39;s online database.&#34;)
            self.smiles = self.pcp_compound[0].connectivity_smiles 
            self.formula = self.pcp_compound[0].molecular_formula
            self.mol = Chem.MolFromSmiles(self.smiles)
        else:
            self.mol = Chem.MolFromSmiles(self.smiles)
            self.formula = CalcMolFormula(self.mol)
            
        self.formula_dict = parse_formula(self.formula)
    
    def load_group_data(self):
        # load group contribution data
        if not isinstance(self.group_data, pd.DataFrame):
            if self.state == &#34;aq&#34;:
                with import_package_file(__name__, &#39;data/group_contribution_data.csv&#39;, as_file=True) as path:
                    self.group_data = pd.read_csv(path, dtype=str)
            elif self.state == &#34;gas&#34;:
                if self.ig_method == &#34;Joback&#34;:
                    with import_package_file(__name__, &#39;data/joback_groups.csv&#39;, as_file=True) as path:
                        self.group_data = pd.read_csv(path, dtype=str)
                else:
                    # load custom gas group
                    self.group_data = pd.read_csv(self.group_data, dtype=str)
            else:
                self.err_handler.raise_exception(&#34;State is unrecognized. Must be either &#39;aq&#39; or &#39;gas&#39;.&#34;)

        self.group_data[&#39;elem&#39;] = self.group_data[&#39;elem&#39;].fillna(&#39;&#39;)
        self.pattern_dict = pd.Series(self.group_data[&#34;elem&#34;].values,
                                      index=self.group_data[&#34;smarts&#34;]).to_dict()
        self.group_data = self.group_data.set_index(&#34;smarts&#34;)

        
    def __set_groups(self):
        
        self.group_matches = pd.DataFrame(self.match_groups(), index=[self.name])

        # remove columns with no matches
        self.group_matches = self.group_matches.loc[:, (self.group_matches.sum(axis=0) != 0)]
        
        # get a list of relevent groups
        self.groups = [grp for grp in self.group_matches.columns if grp != &#34;formula&#34;]
        

    def __entropy(self, unit=&#34;J/mol/K&#34;):
        
        &#34;&#34;&#34;
        Calculate the standard molal entropy of elements in a molecule.
        &#34;&#34;&#34;

        entropies = [(self.element_data.loc[elem, &#34;s&#34;]/self.element_data.loc[elem, &#34;n&#34;])*self.formula_dict[elem] for elem in list(self.formula_dict.keys())]
        if unit == &#34;J/mol/K&#34;:
            unit_conv = 4.184
        elif unit == &#34;cal/mol/K&#34;:
            unit_conv = 1
        else:
            print(&#34;Warning in entropy: specified unit&#34;, unit,
                  &#34;is not recognized. Returning entropy in J/mol/K&#34;)
            unit_conv = 4.184
            
        return sum(entropies)*unit_conv

    @staticmethod
    def dict_to_formula(formula_dict):
        &#34;&#34;&#34;
        Convert a formula dictionary into a formula string.
        Example:
        ```dict_to_formula({&#34;C&#34;:1, &#34;H&#34;:1, &#34;O&#34;:3, &#34;-&#34;:1})```
        will output &#34;HCO3-&#34;

        Parameters
        ----------
        formula_dict : dict
            Dictionary of elements and charge (as keys) and their quantities
            (as values). Meant to be able to reverse the dictionary output of
            chemparse.parse_formula back into a formula string.
            For example, {&#34;C&#34;:1, &#34;H&#34;:1, &#34;O&#34;:3, &#34;-&#34;:1} representing HCO3-
            
        Returns
        ----------
        str
            A chemical formula. E.g., &#34;HCO3-&#34;
        &#34;&#34;&#34;
        
        formula_string = &#34;&#34;
        for key in formula_dict.keys():
            if abs(formula_dict[key]) == 1:
                v = &#34;&#34;
            else:
                v = formula_dict[key]
                if (v).is_integer():
                    v = int(v)

            formula_string = formula_string + str(key) + str(v)
        return formula_string

    
    def match_groups(self):
        &#34;&#34;&#34;
        Match SMARTS strings to a molecule and get a dictionary of group matches.
        This function is meant to be used internally by `Estimate`.
        &#34;&#34;&#34;
        
        patterns = self.pattern_dict.keys()
        mol = Chem.MolFromSmiles(self.smiles)

        match_dict = dict(zip(patterns, [0]*len(patterns))) # initialize match_dict
        for pattern in patterns:
            if pattern != &#34;Yo&#34;: # never match material point
                try:
                    match_dict[pattern] = len(mol.GetSubstructMatches(Chem.MolFromSmarts(pattern)))
                except:
                    print(&#34;Warning in match_groups(): problem&#34;,
                          &#34;identifying SMARTS group&#34;, pattern,
                          &#34;. Skipping this group.&#34;)

        ### check that total formula of groups matches that of the molecule
        
        # create a dictionary of element matches
        total_formula_dict = {}
        for match in match_dict.keys():
            this_match = parse_formula(self.pattern_dict[match])
            for element in this_match.keys():
                this_match[element] *= match_dict[match]
                if element in total_formula_dict:
                    total_formula_dict[element] += this_match[element]
                else:
                    total_formula_dict[str(element)] = 0
                    total_formula_dict[element] += this_match[element]
        
        # remove keys of elements with a value of 0 (e.g. &#34;H&#34;:0.0)
        for key in list(total_formula_dict.keys()):
            if total_formula_dict[key] == 0.0:
                total_formula_dict.pop(key, None)
        
        # retrieve individual charges that contribute to net charge
        all_charges = [a.GetFormalCharge() for a in self.mol.GetAtoms()]
        chargedict = {}
        if any(x != 0 for x in all_charges):
            pos_charge = sum([charge for charge in all_charges if charge &gt; 0])
            neg_charge = abs(sum([charge for charge in all_charges if charge &lt; 0]))
            if pos_charge &gt; 0:
                chargedict[&#39;+&#39;]=float(pos_charge)
            if neg_charge &gt; 0:
                chargedict[&#39;-&#39;]=float(neg_charge)
        else:
            chargedict = {}

        # perform the comparison
        test_dict = parse_formula(self.formula)
        test_dict.update(chargedict)
        if total_formula_dict != test_dict:
            mssg = &#34;The formula of &#34; + self.name + \
                &#34; does not equal the the elemental composition of the &#34; + \
                &#34;matched groups. This could be because the database &#34; + \
                &#34;is missing representative groups.\nFormula of &#34; + \
                self.name + &#34;:\n&#34;
            pcp_dict = parse_formula(self.formula)
            pcp_dict.update(chargedict)
            mssg = mssg + str(pcp_dict) + &#34;\nTotal formula of group matches:\n&#34; + \
                str(total_formula_dict)
            mssg = mssg + &#34;\nIncomplete group matches:\n&#34; + \
                str({k:v for k,v in zip(match_dict.keys(), match_dict.values()) if v!= 0})
            self.err_handler.raise_exception(mssg)
        
        # add molecular formula to match dictionary
        match_dict[&#34;formula&#34;] = self.dict_to_formula(total_formula_dict)
        
        return match_dict


    def display_molecule(self, show=True, save=False):
        &#34;&#34;&#34;
        Display a molecule in a Jupyter notebook or save it as an SVG and PNG.
        This function is meant to be used internally by `Estimate`.
        &#34;&#34;&#34;
        mol_smiles = Chem.MolFromSmiles(self.smiles)
        
        mc = Chem.Mol(mol_smiles.ToBinary())
        molSize=(450, 150)
        
        if not mc.GetNumConformers():
            #Compute 2D coordinates
            rdDepictor.Compute2DCoords(mc)
        # init the drawer with the size
        drawer = rdMolDraw2D.MolDraw2DSVG(molSize[0],molSize[1])
        #draw the molcule
        drawer.DrawMolecule(mc)
        drawer.FinishDrawing()
        # get the SVG string
        svg = drawer.GetDrawingText()

        if show:
            # fix the svg string and display it
            display(SVG(svg.replace(&#39;svg:&#39;,&#39;&#39;)))

        if save:
            os.makedirs(&#34;mol_svg&#34;, exist_ok=True)
            os.makedirs(&#34;mol_png&#34;, exist_ok=True)
            Draw.MolToFile(mol_smiles, &#34;mol_svg/&#34;+self.name+&#34;.svg&#34; )
            Draw.MolToFile(mol_smiles, &#34;mol_png/&#34;+self.name+&#34;.png&#34;)


    def __test_group_match(self):
        match_dict = self.match_groups()
        return {key:value for key,value in zip(match_dict.keys(), match_dict.values()) if value !=0}
        

    def __est_ig(self):
        props = [&#34;Gig&#34;, &#34;Hig&#34;, &#34;Cpig&#34;]
        
        for prop in props:
            err_str = prop + &#34;_err&#34;

            # if property is already defined, skip estimating it
            if prop in dir(self):
                if not self.__getattribute__(prop) is None:
                    continue
            
            mol_prop = 0
            error_groups = []
            mol_err = 999
            prop_errs = []
            n_dec = 999

            for group in self.groups:

                try:
                    contains_group = self.group_matches.loc[self.name, group][0] != 0
                except:
                    contains_group = self.group_matches.loc[self.name, group] != 0

                # if this molecule contains this group...
                if contains_group:
                    try:
                        # add number of groups multiplied by its contribution
                        mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])
                    except:
                        error_groups.append(group)
                    
            if len(error_groups) == 0:
    
                # add Y0
                mol_prop += float(self.group_data.loc[&#34;Yo&#34;, prop])
    
                # propagate error of summed groups: sqrt(a**2 + b**2 + ...)
                mol_err = round(math.sqrt(sum([float(err)**2 for err in prop_errs])), n_dec)
    
                # # format output as string (preserves trailing zeros)
                # mol_prop = format(mol_prop, &#39;.&#39;+str(n_dec)+&#39;f&#39;)
                # mol_err = format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)

                self.__setattr__(prop, mol_prop)
                self.__setattr__(err_str, mol_err)

        if len(error_groups) &gt; 0:
            msg = self.name + &#34; encountered errors with group(s): &#34; +\
                str(error_groups) + &#34;. Are these groups assigned &#34;+\
                &#34;ideal gas properties in the data file?&#34;
            self.err_handler.raise_exception(msg)
                    
        # calculate Sig
        self.Sig = ((self.Gig - self.Hig)/-298.15)*1000 + self.Selements
        
    
    def __est_joback(self):
        
        # values to be added to final estimate of each property
        joback_props = {&#34;Gig&#34;:53.88, &#34;Hig&#34;:68.29, # kJ/mol
                        &#34;Cpig_a&#34;:-37.93, &#34;Cpig_b&#34;:0.210, # j/mol/K
                        &#34;Cpig_c&#34;:-3.91*10**-4, &#34;Cpig_d&#34;:2.06*10**-7} # j/mol/K
        
        for prop in joback_props.keys():
            mol_prop = 0
            error_groups = []

            for group in self.groups:

                try:
                    contains_group = self.group_matches.loc[self.name, group][0] != 0
                except:
                    contains_group = self.group_matches.loc[self.name, group] != 0

                # if this molecule contains this group...
                if contains_group:
                    try:
                        # add number of groups multiplied by its contribution
                        mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])
                    except:
                        error_groups.append(group)
                        
                if len(error_groups) == 0:
                    self.__setattr__(prop, mol_prop+joback_props[prop])

        if len(error_groups) &gt; 0:
            self.err_handler.raise_exception(&#34;&#34; + self.name + &#34; encountered errors with group(s): &#34;
                &#34;&#34;+str(error_groups) + &#34;. Are these groups assigned &#34;
                &#34;ideal gas properties in the Joback data file?&#34;)
            
        # calculate Cpig
        T=298.15
        self.Cpig = self.Cpig_a + self.Cpig_b*T + self.Cpig_c*T**2 +\
                    self.Cpig_d*T**3
        
        # calculate Sig
        self.Sig = ((self.Gig - self.Hig)/-298.15)*1000 + self.Selements
    
    
    def __est_hydration(self, props=[&#34;Gh&#34;, &#34;Hh&#34;, &#34;Sh&#34;, &#34;Cph&#34;, &#34;V&#34;]):

        for prop in props:
            if self.__getattribute__(prop) == None:
                err_str = prop + &#34;_err&#34;

                # derive Sh, entropy of hydration, in J/mol K
                if prop == &#34;Sh&#34;:
                    # Entropy calculated from S = (G-H)/(-Tref)
                    mol_prop = (float(self.Gh) - float(self.Hh))/(-298.15)
                    mol_prop = mol_prop*1000 # convert kJ/molK to J/molK

                    # propagate error from Gh and Hh to estimate Sh error.
                    # equation used: Sh_err = Sh*sqrt((Gh_err/Gh)**2 + (Hh_err/Hh)**2)
                    Gh_err_float = float(self.Gh_err)/float(self.Gh)
                    Hh_err_float = float(self.Hh_err)/float(self.Hh)
                    mol_err = abs(mol_prop)*math.sqrt(Gh_err_float**2 + Hh_err_float**2)

                    # check whether Gh or Hh as the fewest sigfigs
                    sf = min([find_sigfigs(self.Gh), find_sigfigs(self.Hh)])

                    # round Sh to this number of sigfigs
                    mol_prop = sigfig.round(str(mol_prop), sigfigs=sf)

                    # check how many decimal places Sh has after sigfig rounding
                    if &#34;.&#34; in mol_prop:
                        this_split = mol_prop.split(&#34;.&#34;)
                        n_dec = len(this_split[len(this_split)-1])
                    else:
                        n_dec = 0

                    # assign Sh and Sh_err
                    #self.__setattr__(prop, mol_prop) # for trailing zeros, but must store Sh as str.
                    #self.__setattr__(err_str, format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)) # for trailing zeros, but must store Sh_err as str.
                    self.__setattr__(prop, float(mol_prop))
                    self.__setattr__(err_str, round(float(mol_err), n_dec))


                    continue

                # For all properties except for Sh:
                # initialize variables and lists
                mol_prop = 0
                mol_err = 999
                prop_errs = []
                n_dec = 999
                error_groups = []

                for group in self.groups:

                    try:
                        contains_group = self.group_matches.loc[self.name, group][0] != 0
                    except:
                        contains_group = self.group_matches.loc[self.name, group] != 0

                    # if this molecule contains this group...
                    if contains_group:

                        try:
                            # add number of groups multiplied by its contribution
                            mol_prop += self.group_matches.loc[self.name, group] * float(self.group_data.loc[group, prop])
    
                            # round property to smallest number of decimal places
    
                            if not math.isnan(float(self.group_data.loc[group, prop])):
                                if &#34;.&#34; in self.group_data.loc[group, prop]:
                                    this_split = self.group_data.loc[group, prop].split(&#34;.&#34;)
                                    n_dec_group = len(this_split[len(this_split)-1])
                                else:
                                    n_dec_group = 0
    
                                if n_dec_group &lt; n_dec:
                                    n_dec = n_dec_group
        
                                # handle group std errors
                                try:
                                    float(self.group_data.loc[group, err_str]) # assert that this group&#39;s error is numeric
                                    prop_errs.append(self.group_data.loc[group, err_str]) # append error
                                except:
                                    # if group&#39;s error is non-numeric, pass
                                    pass

                        except:
                            error_groups.append(group)

                if len(error_groups) == 0:

                    # add Y0
                    mol_prop += float(self.group_data.loc[&#34;Yo&#34;, prop])

                    # propagate error of summed groups: sqrt(a**2 + b**2 + ...)
                    mol_err = round(math.sqrt(sum([float(err)**2 for err in prop_errs])), n_dec)

#                     # format output as string (preserves trailing zeros)
#                     mol_prop = format(mol_prop, &#39;.&#39;+str(n_dec)+&#39;f&#39;)
#                     mol_err = format(mol_err, &#39;.&#39;+str(n_dec)+&#39;f&#39;)

                    self.__setattr__(prop, mol_prop)
                    self.__setattr__(err_str, mol_err)

                else:
                    msg = self.name + &#34; encountered errors with group(s): &#34; +\
                        str(error_groups) + &#34;. Are these groups assigned &#34;+\
                        &#34;hydration properties in the data file?&#34;
                    self.err_handler.raise_exception(msg)
        
        if self.Gig != None and self.Hig != None and self.Sig != None and self.Cpig != None:
            # no ideal gas estimation needed.
            # TODO: Modify if statement to allow calculating remainder if
            # two out of three are provided for: Gig, Hig, Sig
            pass
        else:
            # Joback estimation of the Gibbs free energy of formation of the
            # ideal gas (Joule-based).
            # try:
            J_estimate = Joback(self.name, smiles=self.smiles)
            
            if self.Gig == None:
                self.Gig = J_estimate[&#34;Gig&#34;]
            if self.Hig == None:
                self.Hig = J_estimate[&#34;Hig&#34;]
            if self.Sig == None:
                self.Sig = ((float(self.Gig) - float(self.Hig))/-298.15)*1000 + self.Selements
            if self.Cpig == None:
                self.Cpig = J_estimate[&#34;Cpig&#34;]
            # except:
            #     if isinstance(self.name, str):
            #         report_name = self.name
            #     elif isinstance(self.smiles, str):
            #         report_name = self.smiles
            #     else:
            #         report_name = &#34;ERROR&#34;
            #     self.err_handler.raise_exception(&#34;The properties of aqueous &#39;&#34;+report_name+&#34;&#39; could not be &#34;
            #         &#34;estimated because its ideal gas properties could not be &#34;
            #         &#34;estimated with the Joback method.&#34;)
                
        # estimate the Gibbs free energy of formation of the aqueous molecule by summing
        # its ideal gas and hydration properties.
        # TODO: if ideal gas properties are NaN, ensure aqueous properties are too.
        # TODO: determine estimation error of ideal gas, then propagate with hydration errors.
        # TODO: propagate errors into HKF parameter estimations.
        
        try:
            if self.Gaq == None:
                self.Gaq = float(self.Gig) + float(self.Gh)
        except:
            self.Gaq = float(&#34;NaN&#34;)

        try:
            if self.Haq == None:
                self.Haq = float(self.Hig) + float(self.Hh)
        except:
            self.Haq = float(&#34;NaN&#34;)

        try:
            if self.Saq == None:
                self.Saq = ((float(self.Gaq) - float(self.Haq))/-298.15)*1000 + self.Selements
        except:
            self.Saq = float(&#34;NaN&#34;)
        try:
            if self.Cpaq == None:
                self.Cpaq = self.Cpig + float(self.Cph)
        except:
            self.Cpaq = float(&#34;NaN&#34;)

        # calculate HKF parameters
        try:
            # find_HKF requires calories
            hkf_dict, eq = find_HKF(Gh=float(self.Gh)*1000/4.184,
                                    V=float(self.V),
                                    Cp=float(self.Cpaq)/4.184,
                                    Gf=float(self.Gaq)*1000/4.184,
                                    Hf=float(self.Haq)*1000/4.184,
                                    Saq=float(self.Saq)/4.184,
                                    Z=float(self.charge),
                                    organic=True)

            properties_to_convert = [&#34;G&#34;, &#34;H&#34;, &#34;S&#34;, &#34;Cp&#34;, &#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]
            for k,v in zip(hkf_dict.keys(), hkf_dict.values()):
                if k in properties_to_convert:
                    hkf_dict[k] = v*4.184
                else:
                    hkf_dict[k] = v

            for param in [&#34;a1&#34;, &#34;a2&#34;, &#34;a3&#34;, &#34;a4&#34;, &#34;c1&#34;, &#34;c2&#34;, &#34;omega&#34;]:
                self.__setattr__(param, hkf_dict[param])

        except:
            print(&#34;Could not calculate HKF parameters for&#34;, self.name)
            pass

    # convert dataframe into an OBIGT table with an option to write to a csv file.
    def __convert_to_OBIGT(self):


        df_prop = {&#39;name&#39;:[self.name],
                   &#39;abbrv&#39;:[self.formula],
                   &#39;formula&#39;:[self.formula],
                   &#39;state&#39;:[&#39;aq&#39;],
                   &#39;ref1&#39;:[&#39;AqOrg&#39;],
                   &#39;ref2&#39;:[&#39;GrpAdd&#39;],
                   &#39;date&#39;:[datetime.now().strftime(&#34;%d/%m/%Y %H:%M:%S&#34;)],
                   &#39;model&#39;:[&#39;HKF&#39;],
                   &#39;E_units&#39;:[&#39;J&#39;],
                   &#39;G&#39;:[float(self.Gaq)*1000],
                   &#39;H&#39;:[float(self.Haq)*1000],
                   &#39;S&#39;:[float(self.Saq)],
                   &#39;Cp&#39;:[float(self.Cpaq)],
                   &#39;V&#39;:[float(self.V)]}
        try:
            # if HKF parameters could be estimated
            df_hkf = {&#39;a1.a&#39;:[float(self.a1)],
                      &#39;a2.b&#39;:[float(self.a2)],
                      &#39;a3.c&#39;:[float(self.a3)],
                      &#39;a4.d&#39;:[float(self.a4)],
                      &#39;c1.e&#39;:[float(self.c1)],
                      &#39;c2.f&#39;:[float(self.c2)],
                      &#39;omega.lambda&#39;:[float(self.omega)],
                      &#39;z.T&#39;:[self.charge]}
        except:
            df_hkf = {&#39;a1.a&#39;:[float(&#34;NaN&#34;)],
                      &#39;a2.b&#39;:[float(&#34;NaN&#34;)],
                      &#39;a3.c&#39;:[float(&#34;NaN&#34;)],
                      &#39;a4.d&#39;:[float(&#34;NaN&#34;)],
                      &#39;c1.e&#39;:[float(&#34;NaN&#34;)],
                      &#39;c2.f&#39;:[float(&#34;NaN&#34;)],
                      &#39;omega.lambda&#39;:[float(&#34;NaN&#34;)],
                      &#39;z.T&#39;:[self.charge]}

        df_prop.update(df_hkf)
        
        df = pd.DataFrame(df_prop)
        
        return df

    def __estimate_hydration(self):
        self.__set_groups()
        self.__est_hydration()
        return self.__convert_to_OBIGT()

    def __estimate_joback(self):
        self.__set_groups()
        self.__est_joback()

    def __estimate_ig(self):
        self.__set_groups()
        self.__est_ig()</code></pre>
</details>
<div class="desc"><p>Estimate thermodynamic properties of an aqueous organic molecule.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Name of the aqueous organic molecule that will have its thermodynamic
properties estimated.</dd>
<dt><strong><code>smiles</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>A SMILES string representing the molecule.</dd>
<dt><strong><code>show</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Show a diagram of the molecule?</dd>
<dt><strong><code>group_data</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Path of a CSV containing custom group contribution data. If <code>state="aq"</code>
then the CSV should contain hydration properties. If <code>state="gas"</code> then
the CSV should contain ideal gas properties.</dd>
<dt><strong><code>test</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Perform a simple group matching test instead of estimating properties?</dd>
<dt><strong><code>state</code></strong> :&ensp;<code>str</code>, default <code>"aq"</code></dt>
<dd>Can be "aq" or "gas". Estimate the properties of an aqueous molecule or
an ideal gas?</dd>
<dt><strong><code>ig_method</code></strong> :&ensp;<code>str</code>, default <code>"Joback"</code></dt>
<dd>Method used to estimate ideal gas properties.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Save molecular structure figures as PNG and SVG?</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>numeric</code> or <code>str</code>, optional</dt>
<dd>
<p>Known standard state partial molal thermodynamic properties at 298.15 K
and 1 bar. These will not be estimated, but instead will be used to
estimate other properties and parameters. Valid **kwargs include:</p>
<ul>
<li>Gh : Gibbs free energy change of hydration, kJ/mol.</li>
<li>Hh : Enthalpy change of hydration, kJ/mol.</li>
<li>Sh : Entropy change of hydration, J/mol/K.</li>
<li>Cph : Heat capacity change of hydration, J/mol/K.</li>
<li>V : Volume change of hydration, cm3/mol.</li>
<li>Gh_err : Error associated with Gh (default 0 kJ/mol).</li>
<li>Hh_err : Error associated with Hh (default 0 kJ/mol).</li>
<li>Sh_err : Error associated with Sh (default 0 J/mol/K).</li>
<li>Cph_err : Error associated with Cph (default 0 J/mol/K).</li>
<li>V_err : error associated with V (default 0 cm3/mol).</li>
<li>Gig : Ideal gas Gibbs free energy of formation, kJ/mol.</li>
<li>Hig : Ideal gas enthalpy of formation, kJ/mol.</li>
<li>Sig : Ideal gas entropy, J/mol/K.</li>
<li>Cpig : Ideal gas isobaric heat capacity, J/mol/K.</li>
<li>Gaq : Aqueous Gibbs free energy of formation, kJ/mol.</li>
<li>Haq : Aqueous enthalpy of formation, kJ/mol.</li>
<li>Saq : Aqueous entropy, J/mol/K.</li>
<li>Cpaq : Aqueous isobaric heat capacity, J/mol/K.</li>
</ul>
</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>pcp_compound</code></strong> :&ensp;<code>pcp.get_compounds()</code></dt>
<dd>PubChemPy compound object.</dd>
<dt><strong><code>smiles</code></strong> :&ensp;<code>str</code></dt>
<dd>Canonical SMILES string.</dd>
<dt><strong><code>formula</code></strong> :&ensp;<code>str</code></dt>
<dd>Molecular formula.</dd>
<dt><strong><code>formula_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of element abundance in the molecular formula.</dd>
<dt><strong><code>element_data</code></strong> :&ensp;<code>pd.DataFrame()</code></dt>
<dd>Table of element data adapted from Jeff Dick's CHNOSZ package for R.</dd>
<dt><strong><code>Selements</code></strong> :&ensp;<code>numeric</code></dt>
<dd>Sum of the contributions of the entropies of the elements according to
Cox, J. D., Wagman, D. D., &amp; Medvedev, V. A. (1989). CODATA key values
for thermodynamics. Chem/Mats-Sci/E.</dd>
<dt><strong><code>note</code></strong> :&ensp;<code>str</code></dt>
<dd>Notes and warnings associated with the estimation.</dd>
<dt><strong><code>charge</code></strong> :&ensp;<code>numeric</code></dt>
<dd>The charge of the molecule.</dd>
<dt><strong><code>OBIGT</code></strong> :&ensp;<code>pd.DataFrame()</code></dt>
<dd>Table of estimated thermodynamic properties and parameters. The format
is styled after Jeff Dick's OBIGT thermodynamic table in the CHNOSZ
package (see <a href="https://chnosz.net/manual/thermo.html">https://chnosz.net/manual/thermo.html</a>).</dd>
<dt><strong><code>hide_traceback</code></strong> :&ensp;<code>bool</code>, default <code>True</code></dt>
<dd>Hide traceback message when encountering errors handled by this function?
When True, error messages handled by this class will be short and to
the point.</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="aqorg.AqOrg.Estimate.dict_to_formula"><code class="name flex">
<span>def <span class="ident">dict_to_formula</span></span>(<span>formula_dict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def dict_to_formula(formula_dict):
    &#34;&#34;&#34;
    Convert a formula dictionary into a formula string.
    Example:
    ```dict_to_formula({&#34;C&#34;:1, &#34;H&#34;:1, &#34;O&#34;:3, &#34;-&#34;:1})```
    will output &#34;HCO3-&#34;

    Parameters
    ----------
    formula_dict : dict
        Dictionary of elements and charge (as keys) and their quantities
        (as values). Meant to be able to reverse the dictionary output of
        chemparse.parse_formula back into a formula string.
        For example, {&#34;C&#34;:1, &#34;H&#34;:1, &#34;O&#34;:3, &#34;-&#34;:1} representing HCO3-
        
    Returns
    ----------
    str
        A chemical formula. E.g., &#34;HCO3-&#34;
    &#34;&#34;&#34;
    
    formula_string = &#34;&#34;
    for key in formula_dict.keys():
        if abs(formula_dict[key]) == 1:
            v = &#34;&#34;
        else:
            v = formula_dict[key]
            if (v).is_integer():
                v = int(v)

        formula_string = formula_string + str(key) + str(v)
    return formula_string</code></pre>
</details>
<div class="desc"><p>Convert a formula dictionary into a formula string.
Example:
<code>dict_to_formula({"C":1, "H":1, "O":3, "-":1})</code>
will output "HCO3-"</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>formula_dict</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary of elements and charge (as keys) and their quantities
(as values). Meant to be able to reverse the dictionary output of
chemparse.parse_formula back into a formula string.
For example, {"C":1, "H":1, "O":3, "-":1} representing HCO3-</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A chemical formula. E.g., "HCO3-"</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="aqorg.AqOrg.Estimate.display_molecule"><code class="name flex">
<span>def <span class="ident">display_molecule</span></span>(<span>self, show=True, save=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_molecule(self, show=True, save=False):
    &#34;&#34;&#34;
    Display a molecule in a Jupyter notebook or save it as an SVG and PNG.
    This function is meant to be used internally by `Estimate`.
    &#34;&#34;&#34;
    mol_smiles = Chem.MolFromSmiles(self.smiles)
    
    mc = Chem.Mol(mol_smiles.ToBinary())
    molSize=(450, 150)
    
    if not mc.GetNumConformers():
        #Compute 2D coordinates
        rdDepictor.Compute2DCoords(mc)
    # init the drawer with the size
    drawer = rdMolDraw2D.MolDraw2DSVG(molSize[0],molSize[1])
    #draw the molcule
    drawer.DrawMolecule(mc)
    drawer.FinishDrawing()
    # get the SVG string
    svg = drawer.GetDrawingText()

    if show:
        # fix the svg string and display it
        display(SVG(svg.replace(&#39;svg:&#39;,&#39;&#39;)))

    if save:
        os.makedirs(&#34;mol_svg&#34;, exist_ok=True)
        os.makedirs(&#34;mol_png&#34;, exist_ok=True)
        Draw.MolToFile(mol_smiles, &#34;mol_svg/&#34;+self.name+&#34;.svg&#34; )
        Draw.MolToFile(mol_smiles, &#34;mol_png/&#34;+self.name+&#34;.png&#34;)</code></pre>
</details>
<div class="desc"><p>Display a molecule in a Jupyter notebook or save it as an SVG and PNG.
This function is meant to be used internally by <code><a title="aqorg.AqOrg.Estimate" href="#aqorg.AqOrg.Estimate">Estimate</a></code>.</p></div>
</dd>
<dt id="aqorg.AqOrg.Estimate.get_mol_smiles_formula_formula_dict"><code class="name flex">
<span>def <span class="ident">get_mol_smiles_formula_formula_dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_mol_smiles_formula_formula_dict(self):
    if not isinstance(self.smiles, str):
        # look up compound on PubChem
        self.pcp_compound = pcp.get_compounds(self.name, &#34;name&#34;)
        if len(self.pcp_compound) == 0:
            self.err_handler.raise_exception(&#34;Could not find &#39;&#34; + self.name + &#34;&#39; in PubChem&#39;s online database.&#34;)
        self.smiles = self.pcp_compound[0].connectivity_smiles 
        self.formula = self.pcp_compound[0].molecular_formula
        self.mol = Chem.MolFromSmiles(self.smiles)
    else:
        self.mol = Chem.MolFromSmiles(self.smiles)
        self.formula = CalcMolFormula(self.mol)
        
    self.formula_dict = parse_formula(self.formula)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="aqorg.AqOrg.Estimate.load_group_data"><code class="name flex">
<span>def <span class="ident">load_group_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_group_data(self):
    # load group contribution data
    if not isinstance(self.group_data, pd.DataFrame):
        if self.state == &#34;aq&#34;:
            with import_package_file(__name__, &#39;data/group_contribution_data.csv&#39;, as_file=True) as path:
                self.group_data = pd.read_csv(path, dtype=str)
        elif self.state == &#34;gas&#34;:
            if self.ig_method == &#34;Joback&#34;:
                with import_package_file(__name__, &#39;data/joback_groups.csv&#39;, as_file=True) as path:
                    self.group_data = pd.read_csv(path, dtype=str)
            else:
                # load custom gas group
                self.group_data = pd.read_csv(self.group_data, dtype=str)
        else:
            self.err_handler.raise_exception(&#34;State is unrecognized. Must be either &#39;aq&#39; or &#39;gas&#39;.&#34;)

    self.group_data[&#39;elem&#39;] = self.group_data[&#39;elem&#39;].fillna(&#39;&#39;)
    self.pattern_dict = pd.Series(self.group_data[&#34;elem&#34;].values,
                                  index=self.group_data[&#34;smarts&#34;]).to_dict()
    self.group_data = self.group_data.set_index(&#34;smarts&#34;)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="aqorg.AqOrg.Estimate.match_groups"><code class="name flex">
<span>def <span class="ident">match_groups</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_groups(self):
    &#34;&#34;&#34;
    Match SMARTS strings to a molecule and get a dictionary of group matches.
    This function is meant to be used internally by `Estimate`.
    &#34;&#34;&#34;
    
    patterns = self.pattern_dict.keys()
    mol = Chem.MolFromSmiles(self.smiles)

    match_dict = dict(zip(patterns, [0]*len(patterns))) # initialize match_dict
    for pattern in patterns:
        if pattern != &#34;Yo&#34;: # never match material point
            try:
                match_dict[pattern] = len(mol.GetSubstructMatches(Chem.MolFromSmarts(pattern)))
            except:
                print(&#34;Warning in match_groups(): problem&#34;,
                      &#34;identifying SMARTS group&#34;, pattern,
                      &#34;. Skipping this group.&#34;)

    ### check that total formula of groups matches that of the molecule
    
    # create a dictionary of element matches
    total_formula_dict = {}
    for match in match_dict.keys():
        this_match = parse_formula(self.pattern_dict[match])
        for element in this_match.keys():
            this_match[element] *= match_dict[match]
            if element in total_formula_dict:
                total_formula_dict[element] += this_match[element]
            else:
                total_formula_dict[str(element)] = 0
                total_formula_dict[element] += this_match[element]
    
    # remove keys of elements with a value of 0 (e.g. &#34;H&#34;:0.0)
    for key in list(total_formula_dict.keys()):
        if total_formula_dict[key] == 0.0:
            total_formula_dict.pop(key, None)
    
    # retrieve individual charges that contribute to net charge
    all_charges = [a.GetFormalCharge() for a in self.mol.GetAtoms()]
    chargedict = {}
    if any(x != 0 for x in all_charges):
        pos_charge = sum([charge for charge in all_charges if charge &gt; 0])
        neg_charge = abs(sum([charge for charge in all_charges if charge &lt; 0]))
        if pos_charge &gt; 0:
            chargedict[&#39;+&#39;]=float(pos_charge)
        if neg_charge &gt; 0:
            chargedict[&#39;-&#39;]=float(neg_charge)
    else:
        chargedict = {}

    # perform the comparison
    test_dict = parse_formula(self.formula)
    test_dict.update(chargedict)
    if total_formula_dict != test_dict:
        mssg = &#34;The formula of &#34; + self.name + \
            &#34; does not equal the the elemental composition of the &#34; + \
            &#34;matched groups. This could be because the database &#34; + \
            &#34;is missing representative groups.\nFormula of &#34; + \
            self.name + &#34;:\n&#34;
        pcp_dict = parse_formula(self.formula)
        pcp_dict.update(chargedict)
        mssg = mssg + str(pcp_dict) + &#34;\nTotal formula of group matches:\n&#34; + \
            str(total_formula_dict)
        mssg = mssg + &#34;\nIncomplete group matches:\n&#34; + \
            str({k:v for k,v in zip(match_dict.keys(), match_dict.values()) if v!= 0})
        self.err_handler.raise_exception(mssg)
    
    # add molecular formula to match dictionary
    match_dict[&#34;formula&#34;] = self.dict_to_formula(total_formula_dict)
    
    return match_dict</code></pre>
</details>
<div class="desc"><p>Match SMARTS strings to a molecule and get a dictionary of group matches.
This function is meant to be used internally by <code><a title="aqorg.AqOrg.Estimate" href="#aqorg.AqOrg.Estimate">Estimate</a></code>.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aqorg" href="index.html">aqorg</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aqorg.AqOrg.Joback" href="#aqorg.AqOrg.Joback">Joback</a></code></li>
<li><code><a title="aqorg.AqOrg.find_sigfigs" href="#aqorg.AqOrg.find_sigfigs">find_sigfigs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aqorg.AqOrg.Estimate" href="#aqorg.AqOrg.Estimate">Estimate</a></code></h4>
<ul class="">
<li><code><a title="aqorg.AqOrg.Estimate.dict_to_formula" href="#aqorg.AqOrg.Estimate.dict_to_formula">dict_to_formula</a></code></li>
<li><code><a title="aqorg.AqOrg.Estimate.display_molecule" href="#aqorg.AqOrg.Estimate.display_molecule">display_molecule</a></code></li>
<li><code><a title="aqorg.AqOrg.Estimate.get_mol_smiles_formula_formula_dict" href="#aqorg.AqOrg.Estimate.get_mol_smiles_formula_formula_dict">get_mol_smiles_formula_formula_dict</a></code></li>
<li><code><a title="aqorg.AqOrg.Estimate.load_group_data" href="#aqorg.AqOrg.Estimate.load_group_data">load_group_data</a></code></li>
<li><code><a title="aqorg.AqOrg.Estimate.match_groups" href="#aqorg.AqOrg.Estimate.match_groups">match_groups</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
